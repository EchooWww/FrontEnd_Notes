# JavaScript

## 0. Basics

### 0.1 Variable declaration

- variables has their scopes: if you declare a variable with a function, it’s local to the function; if you declare it within a loop/ if-else statement, it’s local to the block, but using `var` would break the scope
- So we’d better use `let` or `const`

### 0.2 `this` keyword

- refer to an object when the function is called, when called from the global scope, it refers to the window object of the browser
- If the function is attached to an objet, and called by that object, `this` would be referring the object

### 0.3 Pass-by-value and pass-by-reference

- If the argument is an object, it’s stored in the heap and passed by reference

### 0.4 Object

- Object literal syntax with curly braces {}
- Constructor with new keyword

### 0.5 Data Structures

- array: indexed values []
- set: unique values []
- map: key-value pairs like object, but easier to be looped over

```jsx
const dict = new Map([
  [key1, value1],
  [key2, values],
]);
```

### 0.6 Event loop

- Enables async code runs in a separate thread pool
- `setTimeOut`: 1st argument is the function(callback enqueue in the event loop, will be called back when it’s ready to execute in main stack), 2nd argument is the delay in ms
- `async` and `await`: need to wrap code in to `try-catch` block to handle errors

### 0.7 Export

### 0.8 Arrays

- push: attach the element to the end

```jsx
const friends = ["Micheal", "Steven", "Peter"];
const newLength = friends.push("Echo"); // the push function, attach the element to the end
//push also return the new length of the array
console.log(friends); // ["Micheal", "Steven", "Peter", "Echo"]
```

- unshift: attach the element to the beginning
- pop(): remove the last element, and return the removed element

```jsx
const popped friends.pop();
console.log(popped); // "Echo"
```

- shift(): remove the first element of the array

```jsx
friends.shift();
console.log(friends); // ["Steven", "Peter"]
```

- indexOf(element): return the index of the element

```jsx
console.log(friends.indexOf("Steven")); // 0
console.log(friends.indexOf("Bob")); // -1
```

- includes(): return a boolean whether the array includes the element

### 0.9 Objects

In arrays, we cannot give the values a name, so we use object to define key-value pairs:

```jsx
// in objects, the order of key-value pairs don't matter at all
// we retrive the data based on the name (the 'key')
// object literal syntax
const echo = {
  firstName: "Echo",
  lastName: "Wang",
  age: 2037 - 1996,
  job: "student",
};
```

> Dot / Bracket notation

```jsx
console.log(echo.lastName); //the dot operator, need to specify the realnem
console.log(echo["lastName"]); // in the bracket notation, we can put any expression within the bracket
const nameKey = "Name";
console.log(echo["first" + nameKey]); // we can compute the name in the bracket

const interested = prompt("What do you want to know about Echo?");
console.log(echo[interested]);
```

> Add properties

```jsx
echo.location = 'Canada'
echo['instagram'] = 'Echowww';
console.log(echo);
console.log(`echo has ${echo.friends.length} friends, and her best friend is called ${echo.friends[0]};
```

> Object Methods

we can add functions to object as the ‘value’, aka ‘property’

```jsx
const echo = {
 calcAge: function() {
		this.age =  2037 - this.birthYear; // reference the object itself with `this` keyword
		return this.age;
	}
}
// pay attention: we can only have the function expression instead of the declaration here
// it's equal to `age = function(birthYear){return 2037 - birthYear}`
const age = echo.age;

getSummary : function(){
return (`${this.firstName} is a ${this.calcAge()} -year old ${this.job}, and she has ${this.driverLicense ? 'a': 'no'} driver liscense`)
```

### 0.10 Loops

- continue: exit this iteration and start the next immediately
- break: break the whole loop

```jsx
// this will only print strings
for (let i = 0; i < echo.length; i++) {
		if (typeof(echo[i])!=='string) continue;
		console.log(echo[i], typeof(echo[i]));
}
```

## 1. DOM and events fundamentals

### 1.1 DOM : document object model

> What is DOM?

- A structured representation of HTML documents, allows JavaScript to access HTML elements and styles to manipulate them
- Automatically generated by the browser when a web page loads, it's a tree structure
- In the tree, each node is an object representing a part of the document

  - document: the entry point into the DOM. e.g. `document.querySelector()` it refers to the whole HTML element
  -

> Methods to select elements

- `querySelector()`: select the first element that matches the selector
- `querySelectorAll()`: select all the elements that matches the selector
- `getElementById()`: select the element with the id
- `getElementsByClassName()`: select the elements with the class name, will return a HTML collection, rather than the elements themselves, so we need to speciry the index to get the element
- `textContent`: get the text content of the element
- `innerHTML`: get the HTML content of the element

**DOM is not part of JavaScript, it's part of the web API**

- It's not in the JavaScript language, but it's a part of the browser, which is also written in JavaScript, and we can use it without importing anything

> **Handling events: event listener**

- First, we need to specify where the event happens with DOM selectors, and then we need to listen to the event
- `addEventListener()`: add an event listener to the element, the first argument is the event type, the second argument is the function to be called when the event happens
- the function passed as the 2nd parameter would be called by the event listener function, so we don't need to call it ourselves
- When we pass a function as the second argument, it's called a callback function, so we **don't include the parentheses**, otherwise it would be called immediately

```js
document.querySelector(".check").addEventListener("click", () => {
  console.log("document.querySelector('.guess').value");
});
```

> Modyfing CSS styles with DOM manipulation

- `style`: the style property of the element, it's an object that contains all the CSS styles
- when we want to change the style of an element, we need to specify the property name in camelCase (instead of dash), e.g. `backgroundColor`

> Modifying CSS styles by adding/removing classes from classes list

- `classList`: the classList property of the element, it's an object that contains all the classes of the element
- Instead of changing the style directly, we can add/remove classes from the classList, and then define the style in the CSS file to aggregate the styles

> Handle key press events

- keyboard events are global events, so we don't need to select the element first, we can just use `addEventListener()` on the `document` object
- keyup: when the key is released; keydown: when the key is pressed; keypress: when the key is pressed and held. We usually use keydown
- which key is pressed? we can access the information by the `event` object, which is passed as the first argument of the callback function. `event.key` is the property that we need

> `classList.toggle()`
> A more flexible way to add/remove classes from the classList, it will add the class if it's not there, and remove the class if it's there

## 2. How JavaScript works behind the scenes

### 2.1 JavaScript Overview

- High-level: we don't have to worry about memory management
- Garbage-collected: we don't have to clean up the memory, the language will do it for us
- Interpreted or just-in-time compiled: the code is executed line by line, and the code is not compiled before execution
- Multi-paradigm: we can use different styles of programming, such as OOP, procedural programming, and functional programming, etc.
- Prototype-based object-oriented: regarding OOP, we don't have classes, we have prototypes. Except for primitive values, everything is an object in JavaScript. Objects inherit properties and methods from other objects, and we call it prototype chaining
- First-class functions: functions are treated as first-class citizens, we can pass functions into other functions, and return functions from functions
- Dynamic: we don't have to specify the data type of the variables, and we can change the type of the variables later. (Not like Java, which is static) If we want to use javaScript in a more static way, we can use TypeScript, which is a superset of JavaScript
- Single-threaded: only one command is executed at a time, and new commands are only executed after the previous one is finished. (Concurrency model: the JavaScript engine handles multiple tasks happening at the same time with the event loop and the callback queue)
- Non-blocking event loop: asynchronous behavior, which is very important in modern web development

### 2.2 JavaScript Engine and Runtime

- JS engine: a program that executes JavaScript code. It converts the code into machine code that the computer can understand. It's a part of the browser, e.g., V8 engine in Chrome. Every JS engines includes:
  - Call stack: where our code is executed.
  - Heap: where objects are stored in memory
- Compilation vs. Interpretation
  - Compilation: entire code is converted into machine code at once, and written to a binary file that can be executed by a computer. The code is not executed immediately, but saved and executed later. (e.g. C++) 2 steps: compilation and execution
  - Interpretation: interpreter runs through the source code and executes it line by line. No code is saved, and the code is executed immediately. (e.g. JavaScript) **Much slower** than compilation.
  - **Just-in-time (JIT) compilation [modern javascript use]**: entire code is converted into machine code at once, but the compilation happens just before execution. The code is executed immediately. (e.g. JavaScript). The combination of compilation and interpretation. No portable file is generated, but the code is executed immediately. **Much faster** than interpretation.

> Steps of Modern JavaScript engine working process:

1. Parsing: the code is parsed, and the abstract syntax tree (AST) is generated
2. Compilation: the AST is converted into machine code
3. Execution: the code is executed with a unoptimized machine code to start ASAP, but still to be optimized later
4. Optimization: the code is optimized during execution. The old code is replaced with the optimized code without stopping the execution
5. Compilation: the optimized code is recompiled...

The whole process happens in special threads, not the main thread, so it doesn't block the main thread, and we cannot access the compiled code directly.

> Runtime: where our JavaScript code is executed

1. Runtime in the browser
   Can be imagined as a big box, containing the engine, the web API (e.g., DOM, Timers, Fetch API), and the callback queue(e.g., the event handler functions. When the event happens, the callback function is put into the callback queue. When the call stack is empty, the callback function is put into the call stack to be executed)
   > Event loop: takes callback functions from the callback queue and puts them in the call stack, so that they can be executed
2. Runtime in Node.js
   Similar to the browser, but we don't have web APIs in Node.js, instead, we have C++ bindings, such as file system APIs, HTTP APIs, etc. We also have a thread pool, which is used to handle expensive tasks, such as image processing, etc.

### 2.3 Execution Contexts and the Call Stack

> Sequence:

1. When the first compilation is finished, the global execution context is created(for top-level code). There's only one global execution context in the call stack
   - Execution context: a wrapper to help manage the code that is running. It contains all necessary information for the execution of the code that is inside it.
2. Execution of functions and waiting for asynchronous tasks happen in the execution context
   - One execution context for each **function call**
3. All the execution contexts together form the call stack
   - Call stack: where execution contexts get stacked on top of each other, to keep track of where we are in the execution

> Execution context: contains 3 things

1. Variable environment: let, const, var, function declarations, and arguments object.
2. Scope chain: current variable environment and the variable environment of all the parent execution contexts
3. this keyword

_Special case_: the arrow function doesn't get its own this keyword and the arguments object. Instead, they use the this keyword and the arguments object of their parent execution context.

> Call Stack: where execution contexts get stacked on top of each other, to keep track of where we are in the execution

- The execution context on top of the call stack is the one that is currently running. When the function returns, the execution context is removed from the call stack, and the execution continues in the execution context below it.
- The global execution context is always at the bottom of the call stack.
- Javascript is one-threaded, we can only execute one piece of code at a time. The call stack is a map for the JS engine to know where it is in the execution.
- Only when we close the tab, the call stack is cleared, the global execution context is removed, and the JS engine is shut down.

### 2.4 Scope and the Scope Chain

> Concepts

- Scoping: Where do variables live?
- Lexical scoping: Javascript use lexical scoping (static scoping), which means the scope is determined at the time of the creation of the function.
- Scope: the space or environment in which a certain variable is declared. There are 3 types of scope: global scope, function scope, and block scope.
- Scope of a variable: region of our code where a certain variable can be accessed. (e.g., global scope, function scope, block scope, etc.)

> 3 types of scope

- Global scope: variables declared outside of any function or block. They are accessible everywhere in the code.
- Function/ local scope: variables declared inside a function. They are only accessible inside that function. (variables declared with var are function scoped)
- Block scope: variables declared inside a block. A block is a piece of code wrapped in curly braces. They are only accessible inside that block. （only applies to variables declared with **let and const and functions**）

> Scope chain

- current variable environment and the variable environment of all the parent execution contexts
- Variable lookup: the variables are not copied from parent scope to child scope, but the child scope has access to the variables in the parent scope. When we try to access a variable, the JS engine will look for the variable in the current scope, and if it cannot find the variable, it will look for the variable in the parent scope, and so on.
- Sibling scopes: the scopes that are on the same level of the scope chain. They don't have access to each other's variables.

> Scope chain and the call stack

- The scope chain has nothing to do with the execution context of the call stack. If a function is called(but not declared) inside another function, the function will not have access to the variables in the parent function.
  ![Alt text](image.png)
- If we declare a global variable again in a function/ block, and use that variable inside the function/ block, the variable will be shadowed. The variable in the function/ block will be used, and the global variable will not be affected.
- But if we change the value of a global variable inside a function/ block, the global variable will be changed.

### 2.5 Hoisting

Hoisting: makes some types of variables accessible/ usable in the code before they are actually declared.Behind the scenes, at the creation phase of our execution contest, the code is scanned for variable declarations, and for each variable, a new property is created in the variable environment object.

| Variable type                        | Hoisted?               | Initial value                        | Scope          |
| ------------------------------------ | ---------------------- | ------------------------------------ | -------------- |
| var                                  | yes                    | undefined                            | function scope |
| let & const                          | no                     | < unitialized > , temporal dead zone | block scope    |
| function declarstions                | no                     | -                                    | block scope    |
| function expressions/ Arrow function | depends on the keyword | -                                    | block scope    |

- Temporal dead zone: within the scope, but before the declaration. We cannot access the variable in TDZ. We'll get a reference error: cannot access before initialization. If we try to access the variable not ever declared, we'll get a 'is not defined' error.
- Accessing a variable before it is declared is a bad practice, and should be avoided.
- Hoisting var variables is actually byproduct of hoisting functions. For variables, we shouldn't use that
- One more difference for var variables: it is an attribute of the window object, so we can access it using window.variableName

> Best practices

- Declare variables at the top of each scope
- Don't use var keyword, use let and const instead
- Even for function declarations which could be hoisted, it's better to declare them at the top of the scope, before they are used.

### 2.6 The this Keyword

> Concepts of this keyword

- A special variable created for each execution context (every function). Takes the value of (points to) the "owner" of the function in which the this keyword is used.
- `this` is not static, it depends on how the function is called, and its value is only assigned when the function is **actually called**.
  - Method: this = object that is calling the method
  - Simple function call: this = undefined (in strict mode), or window object (in non-strict mode)
  - Arrow functions: this = this of surrounding function (if arrow function is declared on the global scope, this = window object)
  - Event listener: this = DOM element that the handler is attached to
- `this` is never pointing to the function itself, and it's also not pointing to the variable environment of the function.

> What if we want to call the object within a simple function call inside a method attribute?

- We can decalre a new variable and assign `this` to the variable, and then use the variable to access the object.
- The more modern way: use arrow functions, because arrow functions don't get their own `this` keyword, they use the `this` keyword of their parent scope, which is the object in this case.

### 2.7 Arguments Keyword

- We can get the arguments passed into a function using the `arguments` keyword. It is an array-like structure.
- Also, arrow functions don't get their own `arguments` keyword.

### 2.8 Primitives vs. Objects

> Concepts

- Number, string, boolean, undefined, null, symbol, bigint
- All the others are objects: arrays, functions, object literal

> Engine: call stack & heap

- Primitive values: stored in the call stack (in the execution context)
- objects: stored in the heap (in the heap section of the memory)

> How they works

- Primitive values: immutable, when we change the value, we actually create a new value in the call stack and point to it, and the old value is still there.
- Reference values: the address in the call stack pointing to memory in the heap, where the value is stored. If we assign a new variable to the object, the new variable will point to the same address in the call stack, and the value in the heap will not be copied. If we change the value of some attribute, the value in the heap will be changed, and all the variables pointing to that value will be changed.
- We can change the attribute of object declared with `const`, but we cannot change the value of the object (the address). The unchanged value is in the call stack, and the changed value is in the heap.
- What if we want to change an attribute value of the copy of the object? We can use `Object.assign()` to create a new object, and then change the value of the new object.
- The `Object.assign()` only creates a shallow copy, which means that if the object has another object as an attribute, the new object will still point to the same address in the heap as the old object.

  ```js
  const jessica = {
    firstName: "Jessica",
    lastName: "Williams",
    age: 27,
    family: ["Alice", "Bob"],
  };
  const marriedJessica = Object.assign({}, jessica);
  marriedJessica.lastName = "Davis";
  marriedJessica.family.push("Mary"); // this line will change the value of jessica.family as well
  console.log("Before marriage: ", jessica);
  console.log("After marriage: ", marriedJessica);
  // Before marriage:  {firstName: "Jessica", lastName: "Williams", age: 27, family: Array(3)}
  // After marriage:  {firstName: "Jessica", lastName: "Davis", age: 27, family: Array(3)}
  ```

- To deep-clone, we need some external libraries, such as lodash.

## 3. Data Structures, Modern Operators and Strings

### 3.1 Destructuring Arrays
