# JavaScript

## 0. Basics

### 0.1 Variable declaration

- variables has their scopes: if you declare a variable with a function, it’s local to the function; if you declare it within a loop/ if-else statement, it’s local to the block, but using `var` would break the scope
- So we’d better use `let` or `const`

### 0.2 `this` keyword

- refer to an object when the function is called, when called from the global scope, it refers to the window object of the browser
- If the function is attached to an object, and called by that object, `this` would be referring the object
- In an event handler, `this` refers to the DOM element that the handler is attached to>

### 0.3 Pass-by-value and pass-by-reference

- If the argument is an object, it’s stored in the heap and passed by reference

### 0.4 Object

- Object literal syntax with curly braces {}
- Constructor with new keyword

### 0.5 Data Structures

- array: indexed values []
- set: unique values []
- map: key-value pairs like object, but easier to be looped over

```jsx
const dict = new Map([
  [key1, value1],
  [key2, values],
]);
```

### 0.6 Event loop

- Enables async code runs in a separate thread pool
- `setTimeOut`: 1st argument is the function(callback enqueue in the event loop, will be called back when it’s ready to execute in main stack), 2nd argument is the delay in ms
- `async` and `await`: need to wrap code in to `try-catch` block to handle errors

### 0.7 Export

### 0.8 Arrays

- push: attach the element to the end

```jsx
const friends = ["Micheal", "Steven", "Peter"];
const newLength = friends.push("Echo"); // the push function, attach the element to the end
//push also return the new length of the array
console.log(friends); // ["Micheal", "Steven", "Peter", "Echo"]
```

- unshift: attach the element to the beginning
- pop(): remove the last element, and return the removed element

```jsx
const popped friends.pop();
console.log(popped); // "Echo"
```

- shift(): remove the first element of the array

```jsx
friends.shift();
console.log(friends); // ["Steven", "Peter"]
```

- indexOf(element): return the index of the element

```jsx
console.log(friends.indexOf("Steven")); // 0
console.log(friends.indexOf("Bob")); // -1
```

- includes(): return a boolean whether the array includes the element
- join(): join the elements in the array with the specified separator to a string

### 0.9 Objects

In arrays, we cannot give the values a name, so we use object to define key-value pairs:

```jsx
// in objects, the order of key-value pairs don't matter at all
// we retrive the data based on the name (the 'key')
// object literal syntax
const echo = {
  firstName: "Echo",
  lastName: "Wang",
  age: 2037 - 1996,
  job: "student",
};
```

> Dot / Bracket notation

```jsx
console.log(echo.lastName); //the dot operator, need to specify the realnem
console.log(echo["lastName"]); // in the bracket notation, we can put any expression within the bracket
const nameKey = "Name";
console.log(echo["first" + nameKey]); // we can compute the name in the bracket

const interested = prompt("What do you want to know about Echo?");
console.log(echo[interested]);
```

> Add properties

```jsx
echo.location = 'Canada'
echo['instagram'] = 'Echowww';
console.log(echo);
console.log(`echo has ${echo.friends.length} friends, and her best friend is called ${echo.friends[0]};
```

> Object Methods

we can add functions to object as the ‘value’, aka ‘property’

```jsx
const echo = {
 calcAge: function() {
		this.age =  2037 - this.birthYear; // reference the object itself with `this` keyword
		return this.age;
	}
}
// pay attention: we can only have the function expression instead of the declaration here
// it's equal to `age = function(birthYear){return 2037 - birthYear}`
const age = echo.age;

getSummary : function(){
return (`${this.firstName} is a ${this.calcAge()} -year old ${this.job}, and she has ${this.driverLicense ? 'a': 'no'} driver liscense`)
```

### 0.10 Loops

- continue: exit this iteration and start the next immediately
- break: break the whole loop

```jsx
// this will only print strings
for (let i = 0; i < echo.length; i++) {
		if (typeof(echo[i])!=='string) continue;
		console.log(echo[i], typeof(echo[i]));
}
```

## 1. DOM and events fundamentals

### 1.1 DOM : document object model

> What is DOM?

- A structured representation of HTML documents, allows JavaScript to access HTML elements and styles to manipulate them
- Automatically generated by the browser when a web page loads, it's a tree structure
- In the tree, each node is an object representing a part of the document

  - document: the entry point into the DOM. e.g. `document.querySelector()` it refers to the whole HTML element
  -

> Methods to select elements

- `querySelector()`: select the first element that matches the selector
- `querySelectorAll()`: select all the elements that matches the selector
- `getElementById()`: select the element with the id
- `getElementsByClassName()`: select the elements with the class name, will return a HTML collection, rather than the elements themselves, so we need to speciry the index to get the element
- `textContent`: get the text content of the element
- `innerHTML`: get the HTML content of the element

**DOM is not part of JavaScript, it's part of the web API**

- It's not in the JavaScript language, but it's a part of the browser, which is also written in JavaScript, and we can use it without importing anything

> **Handling events: event listener**

- First, we need to specify where the event happens with DOM selectors, and then we need to listen to the event
- `addEventListener()`: add an event listener to the element, the first argument is the event type, the second argument is the function to be called when the event happens
- the function passed as the 2nd parameter would be called by the event listener function, so we don't need to call it ourselves
- When we pass a function as the second argument, it's called a callback function, so we **don't include the parentheses**, otherwise it would be called immediately

```js
document.querySelector(".check").addEventListener("click", () => {
  console.log("document.querySelector('.guess').value");
});
```

> Modyfing CSS styles with DOM manipulation

- `style`: the style property of the element, it's an object that contains all the CSS styles
- when we want to change the style of an element, we need to specify the property name in camelCase (instead of dash), e.g. `backgroundColor`

> Modifying CSS styles by adding/removing classes from classes list

- `classList`: the classList property of the element, it's an object that contains all the classes of the element
- Instead of changing the style directly, we can add/remove classes from the classList, and then define the style in the CSS file to aggregate the styles

> Handle key press events

- keyboard events are global events, so we don't need to select the element first, we can just use `addEventListener()` on the `document` object
- keyup: when the key is released; keydown: when the key is pressed; keypress: when the key is pressed and held. We usually use keydown
- which key is pressed? we can access the information by the `event` object, which is passed as the first argument of the callback function. `event.key` is the property that we need

> `classList.toggle()`
> A more flexible way to add/remove classes from the classList, it will add the class if it's not there, and remove the class if it's there

## 2. How JavaScript works behind the scenes

### 2.1 JavaScript Overview

- High-level: we don't have to worry about memory management
- Garbage-collected: we don't have to clean up the memory, the language will do it for us
- Interpreted or just-in-time compiled: the code is executed line by line, and the code is not compiled before execution
- Multi-paradigm: we can use different styles of programming, such as OOP, procedural programming, and functional programming, etc.
- Prototype-based object-oriented: regarding OOP, we don't have classes, we have prototypes. Except for primitive values, everything is an object in JavaScript. Objects inherit properties and methods from other objects, and we call it prototype chaining
- First-class functions: functions are treated as first-class citizens, we can pass functions into other functions, and return functions from functions
- Dynamic: we don't have to specify the data type of the variables, and we can change the type of the variables later. (Not like Java, which is static) If we want to use javaScript in a more static way, we can use TypeScript, which is a superset of JavaScript
- Single-threaded: only one command is executed at a time, and new commands are only executed after the previous one is finished. (Concurrency model: the JavaScript engine handles multiple tasks happening at the same time with the event loop and the callback queue)
- Non-blocking event loop: asynchronous behavior, which is very important in modern web development

### 2.2 JavaScript Engine and Runtime

- JS engine: a program that executes JavaScript code. It converts the code into machine code that the computer can understand. It's a part of the browser, e.g., V8 engine in Chrome. Every JS engines includes:
  - Call stack: where our code is executed.
  - Heap: where objects are stored in memory
- Compilation vs. Interpretation
  - Compilation: entire code is converted into machine code at once, and written to a binary file that can be executed by a computer. The code is not executed immediately, but saved and executed later. (e.g. C++) 2 steps: compilation and execution
  - Interpretation: interpreter runs through the source code and executes it line by line. No code is saved, and the code is executed immediately. (e.g. JavaScript) **Much slower** than compilation.
  - **Just-in-time (JIT) compilation [modern javascript use]**: entire code is converted into machine code at once, but the compilation happens just before execution. The code is executed immediately. (e.g. JavaScript). The combination of compilation and interpretation. No portable file is generated, but the code is executed immediately. **Much faster** than interpretation.

> Steps of Modern JavaScript engine working process:

1. Parsing: the code is parsed, and the abstract syntax tree (AST) is generated
2. Compilation: the AST is converted into machine code
3. Execution: the code is executed with a unoptimized machine code to start ASAP, but still to be optimized later
4. Optimization: the code is optimized during execution. The old code is replaced with the optimized code without stopping the execution
5. Compilation: the optimized code is recompiled...

The whole process happens in special threads, not the main thread, so it doesn't block the main thread, and we cannot access the compiled code directly.

> Runtime: where our JavaScript code is executed

1. Runtime in the browser
   Can be imagined as a big box, containing the engine, the web API (e.g., DOM, Timers, Fetch API), and the callback queue(e.g., the event handler functions. When the event happens, the callback function is put into the callback queue. When the call stack is empty, the callback function is put into the call stack to be executed)
   > Event loop: takes callback functions from the callback queue and puts them in the call stack, so that they can be executed
2. Runtime in Node.js
   Similar to the browser, but we don't have web APIs in Node.js, instead, we have C++ bindings, such as file system APIs, HTTP APIs, etc. We also have a thread pool, which is used to handle expensive tasks, such as image processing, etc.

### 2.3 Execution Contexts and the Call Stack

> Sequence:

1. When the first compilation is finished, the global execution context is created(for top-level code). There's only one global execution context in the call stack
   - Execution context: a wrapper to help manage the code that is running. It contains all necessary information for the execution of the code that is inside it.
2. Execution of functions and waiting for asynchronous tasks happen in the execution context
   - One execution context for each **function call**
3. All the execution contexts together form the call stack
   - Call stack: where execution contexts get stacked on top of each other, to keep track of where we are in the execution

> Execution context: contains 3 things

1. Variable environment: let, const, var, function declarations, and arguments object.
2. Scope chain: current variable environment and the variable environment of all the parent execution contexts
3. this keyword

_Special case_: the arrow function doesn't get its own this keyword and the arguments object. Instead, they use the this keyword and the arguments object of their parent execution context.

> Call Stack: where execution contexts get stacked on top of each other, to keep track of where we are in the execution

- The execution context on top of the call stack is the one that is currently running. When the function returns, the execution context is removed from the call stack, and the execution continues in the execution context below it.
- The global execution context is always at the bottom of the call stack.
- Javascript is one-threaded, we can only execute one piece of code at a time. The call stack is a map for the JS engine to know where it is in the execution.
- Only when we close the tab, the call stack is cleared, the global execution context is removed, and the JS engine is shut down.

### 2.4 Scope and the Scope Chain

> Concepts

- Scoping: Where do variables live?
- Lexical scoping: Javascript use lexical scoping (static scoping), which means the scope is determined at the time of the creation of the function.
- Scope: the space or environment in which a certain variable is declared. There are 3 types of scope: global scope, function scope, and block scope.
- Scope of a variable: region of our code where a certain variable can be accessed. (e.g., global scope, function scope, block scope, etc.)

> 3 types of scope

- Global scope: variables declared outside of any function or block. They are accessible everywhere in the code.
- Function/ local scope: variables declared inside a function. They are only accessible inside that function. (variables declared with var are function scoped)
- Block scope: variables declared inside a block. A block is a piece of code wrapped in curly braces. They are only accessible inside that block. （only applies to variables declared with **let and const and functions**）

> Scope chain

- current variable environment and the variable environment of all the parent execution contexts
- Variable lookup: the variables are not copied from parent scope to child scope, but the child scope has access to the variables in the parent scope. When we try to access a variable, the JS engine will look for the variable in the current scope, and if it cannot find the variable, it will look for the variable in the parent scope, and so on.
- Sibling scopes: the scopes that are on the same level of the scope chain. They don't have access to each other's variables.

> Scope chain and the call stack

- The scope chain has nothing to do with the execution context of the call stack. If a function is called(but not declared) inside another function, the function will not have access to the variables in the parent function.
  ![Alt text](image.png)
- If we declare a global variable again in a function/ block, and use that variable inside the function/ block, the variable will be shadowed. The variable in the function/ block will be used, and the global variable will not be affected.
- But if we change the value of a global variable inside a function/ block, the global variable will be changed.

### 2.5 Hoisting

Hoisting: makes some types of variables accessible/ usable in the code before they are actually declared.Behind the scenes, at the creation phase of our execution contest, the code is scanned for variable declarations, and for each variable, a new property is created in the variable environment object.

| Variable type                        | Hoisted?               | Initial value                        | Scope          |
| ------------------------------------ | ---------------------- | ------------------------------------ | -------------- |
| var                                  | yes                    | undefined                            | function scope |
| let & const                          | no                     | < unitialized > , temporal dead zone | block scope    |
| function declarations                | yes                    | -                                    | block scope    |
| function expressions/ Arrow function | depends on the keyword | -                                    | block scope    |

- Temporal dead zone: within the scope, but before the declaration. We cannot access the variable in TDZ. We'll get a reference error: cannot access before initialization. If we try to access the variable not ever declared, we'll get a 'is not defined' error.
- Accessing a variable before it is declared is a bad practice, and should be avoided.
- Hoisting var variables is actually byproduct of hoisting functions. For variables, we shouldn't use that
- One more difference for var variables: it is an attribute of the window object, so we can access it using window.variableName

> Best practices

- Declare variables at the top of each scope
- Don't use var keyword, use let and const instead
- Even for function declarations which could be hoisted, it's better to declare them at the top of the scope, before they are used.

### 2.6 The this Keyword

> Concepts of this keyword

- A special variable created for each execution context (every function). Takes the value of (points to) the "owner" of the function in which the this keyword is used.
- `this` is not static, it depends on how the function is called, and its value is only assigned when the function is **actually called**.
  - Method: this = object that is calling the method
  - Simple function call: this = undefined (in strict mode), or window object (in non-strict mode)
  - Arrow functions: this = this of surrounding function (if arrow function is declared on the global scope, this = window object)
  - Event listener: this = DOM element that the handler is attached to
- `this` is never pointing to the function itself, and it's also not pointing to the variable environment of the function.

> What if we want to call the object within a simple function call inside a method attribute?

- We can decalre a new variable and assign `this` to the variable, and then use the variable to access the object.
- The more modern way: use arrow functions, because arrow functions don't get their own `this` keyword, they use the `this` keyword of their parent scope, which is the object in this case.

### 2.7 Arguments Keyword

- We can get the arguments passed into a function using the `arguments` keyword. It is an array-like structure.
- Also, arrow functions don't get their own `arguments` keyword.

### 2.8 Primitives vs. Objects

> Concepts

- Number, string, boolean, undefined, null, symbol, bigint
- All the others are objects: arrays, functions, object literal

> Engine: call stack & heap

- Primitive values: stored in the call stack (in the execution context)
- objects: stored in the heap (in the heap section of the memory)

> How they works

- Primitive values: immutable, when we change the value, we actually create a new value in the call stack and point to it, and the old value is still there.
- Reference values: the address in the call stack pointing to memory in the heap, where the value is stored. If we assign a new variable to the object, the new variable will point to the same address in the call stack, and the value in the heap will not be copied. If we change the value of some attribute, the value in the heap will be changed, and all the variables pointing to that value will be changed.
- We can change the attribute of object declared with `const`, but we cannot change the value of the object (the address). The unchanged value is in the call stack, and the changed value is in the heap.
- What if we want to change an attribute value of the copy of the object? We can use `Object.assign()` to create a new object, and then change the value of the new object.
- The `Object.assign()` only creates a shallow copy, which means that if the object has another object as an attribute, the new object will still point to the same address in the heap as the old object.

```js
const jessica = {
  firstName: "Jessica",
  lastName: "Williams",
  age: 27,
  family: ["Alice", "Bob"],
};
const marriedJessica = Object.assign({}, jessica);
marriedJessica.lastName = "Davis";
marriedJessica.family.push("Mary"); // this line will change the value of jessica.family as well
console.log("Before marriage: ", jessica);
console.log("After marriage: ", marriedJessica);
// Before marriage:  {firstName: "Jessica", lastName: "Williams", age: 27, family: Array(3)}
// After marriage:  {firstName: "Jessica", lastName: "Davis", age: 27, family: Array(3)}
```

- To deep-clone, we need some external libraries, such as lodash.

## 3. Data Structures, Modern Operators and Strings

### 3.1 Destructuring Arrays

A ESX feature that allows us to easily extract array elements or object properties and store them in variables.

```js
const arr = [2, 3, 4];
const [x, y, z] = arr;
console.log(x, y, z); // 2 3 4
```

If we only want to extract the first n elements, we can also use this syntax

```js
const [x, y] = arr;
console.log(x, y); // 2 3
```

If we wanna skip some elements, we can use empty commas

```js
const [x, , z] = arr;
console.log(x, z); // 2 4
```

We can also use destructuring to switch variables

```js
let [main, secondary] = restaurant.categories;
console.log(main, secondary); // Italian Vegetarian
[main, secondary] = [secondary, main];
console.log(main, secondary); // Vegetarian Italian
```

Receive return values from a function

```js
const [starter, mainCourse] = restaurant.order(2, 0);
console.log(starter, mainCourse); // Garlic Bread Pizza
```

Nested array destructuring

```js
const nested = [2, 4, [5, 6]];
const [i, , j] = nested;
console.log(i, j); // 2 [5, 6]
// destruct immediately
const [i, , [j, k]] = nested;
console.log(i, j, k); // 2 5 6
```

Set default values

```js
const [p = 1, q = 1, r = 1] = [8, 9];
console.log(p, q, r); // 8 9 1
```

### 3.2 Destructuring Objects

We destructure the objects with curly braces and the attribute names. The order doesn't matter, but the names must match: especially useful when we receive data from an API.

```js
const { name, openingHours, categories } = restaurant;
console.log(name, openingHours, categories); // Classico Italian ['Italian', 'Vegetarian', 'Organic']
```

What if we want the variable names to be different from the attribute names? We can use the colon to assign new names.

```js
const {
  name: restaurantName, // first the attribute name, our variable name after the colon
  openingHours: hours,
  categories: tags,
} = restaurant;
```

Have default values

```js
const { menu = [], starterMenu: starters = [] } = restaurant;
console.log(menu, starters); // [] ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad']
```

Mutating variables: we need to have a pair of parentheses around the whole destructuring assignment.

```js
let a = 111;
let b = 999;
const obj = { a: 23, b: 7, c: 14 };
({ a, b } = obj);
```

Nested objects

```js
const {
  fri: { open: o, close: c },
} = openingHours;
console.log(o, c); // 11 23
```

We can also use destructuring to pass objects into functions. We don't need multiple arguments and can pass the attributes in any order.

```js
orderDelivery: function ({ starterIndex = 1, mainIndex= 0, time= '20:00', address }) {
    console.log(
      // we can access the variables directly without specifying 4 arguments
      `Order received! ${this.starterMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be delivered to ${address} at ${time}`
    );
  },


restaurant.orderDelivery({
time: "22:30",
address: "Via del Sole, 21",
mainIndex: 2,
starterIndex: 2,
});

```

### 3.3 The Spread Operator

Add elements to arrays

```js
const arr = [7, 8, 9];
const badNewArr = [1, 2, arr[0], arr[1], arr[2]];
console.log(badNewArr); // [1, 2, 7, 8, 9]
const newArr = [1, 2, ...arr];
console.log(newArr); // [1, 2, 7, 8, 9]
```

We can also use the spread operator to get the elements of the array individually

```js
console.log(...newArr); // 1 2 7 8 9
```

Add elements and create a new array: we are not manipulating the original array.
The big difference between the spread operator and destructuring is that the spread operator takes all the elements out of the array, while destructuring creates new variables.

```js
const newMenu = [...restaurant.mainMenu, "Gnocci"];
console.log(newMenu); // ['Pizza', 'Pasta', 'Risotto', 'Gnocci']
```

Copy array

```js
const mainMenuCopy = [...restaurant.mainMenu];
```

Join 2 arrays or more

```js
const menu = [...restaurant.starterMenu, ...restaurant.mainMenu];
console.log(menu); // ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad', 'Pizza', 'Pasta', 'Risotto'] Containing elements from both arrays
```

Iterables: arrays, strings, maps, sets. Objects are **not iterable**. So we can use the spread operator with these data structures as well. We can only use the spread operator when building an array or when we pass values into a function.

```js
const str = "Jonas";
const letters = [...str, " ", "S."];
console.log(letters); // ['J', 'o', 'n', 'a', 's', ' ', 'S', '.']
console.log(...str); // J o n a s
```

We cannot use the spread operator as string literal, only **building arrays** or **passing values** into functions.

```js
console.log(`${...str} Schmedtmann`); // Uncaught SyntaxError: Unexpected token '...'
```

Pass values into functions

```js
const ingredients = [
  prompt("Let's make pasta! Ingredient 1?"),
  prompt("Ingredient 2?"),
  prompt("Ingredient 3?"),
];
console.log(ingredients); // ['garlic', 'olive oil', 'tomatoes']
restaurant.orderPasta(...ingredients);
```

Spread operator also works on objects, even though obejcts are not iterables. It's similar to destructuring, but it does not create new variables.

```js
const restaurantCopy = { ...restaurant };
```

### 3.4 Rest Pattern and Parameters

- The opposite of spread operator. It packs elements into an array. It's used in destructuring and functions.
- The main difference is where we use `...`. If we use it on the left side of the assignment operator, it's called the **rest operator**. If we use it on the right side of the assignment operator, it's called the **spread operator**.
- The rest operator must be the **last** element.
- There is at most **one** rest parameter in a function.

```js
// SPREAD, because on RIGHT side of =
const arr = [1, 2, ...[3, 4]];
console.log(arr); // [1, 2, 3, 4]

// REST, because on LEFT side of =
const [a, b, ...others] = [1, 2, 3, 4, 5];
console.log(a, b, others); // 1 2 [3, 4, 5]

// Both sides, the rest operator must be the last element
const [pizza, , risotto, ...otherFood] = [
  ...restaurant.mainMenu,
  ...restaurant.starterMenu,
];
console.log(pizza, risotto, otherFood); // Pizza Risotto ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad']

// Objects with rest operator
const { sat, ...weekdays } = restaurant.openingHours;
console.log(weekdays);
```

- How rest operator works: grabs elements and pack them into an array.

```js
// the rest operator in our argument means it will take all the arguments and pack them into an array called `numbers`
const add = function (...numbers) {
  console.log(numbers);
};
add(2, 3); // [2, 3]
add(5, 3, 7, 2); // [5, 3, 7, 2]
add(8, 2, 5, 3, 2, 1, 4); // [8, 2, 5, 3, 2, 1, 4]
const x = [23, 5, 7];
add(...x); // [23, 5, 7]
// we use rest when defining a function, and we use spread when calling a function, to make the function can either accept multiple values or an array, it's more flexible
```

### 3.5 Short Circuiting (&& and ||)

&& and || can be used with any data type, and they can return any data type, not only boolean. They can also short circuit the evaluation of any expression.

- They can use any data type
- They can return any data type connected by the operator (not only boolean)
- They do short-circuit evaluation

1. for || operator, if the first value is a truthy value, it will immediately return that first value, and it will not even evaluate the second operand. If the first value is a falsy value, it will immediately return the second value.
2. for && operator, if the first value is a falsy value, it will immediately return that first value, and it will not even evaluate the second operand. If the first value is a truthy value, it will immediately return the second value.

```js
// --- OR ---
// return the first truthy value or the last value if all are falsy
console.log(3 || "Jonas"); // 3
console.log("" || "Jonas"); // Jonas
console.log(true || 0); // true
console.log(undefined || null); // null
console.log(undefined || 0 || "" || "Hello" || 23 || null); // Hello
// In practical, we can use it to set default values
const guest1 = restaurant.numGuests ? restaurant.numGuests : 10;
// can be simplified as
const guest2 = restaurant.numGuests || 10;

// --- AND ---
// return the first falsy value or the last value if all are truthy
console.log(0 && "Jonas"); // 0
console.log(7 && "Jonas"); // Jonas
console.log("Hello" && 23 && null && "Jonas"); // null

// Practical example, to execute the second function only if the first function exists
if (restaurant.orderPizza) {
  restaurant.orderPizza("mushrooms", "spinach");
}
// can be simplified as
restaurant.orderPizza && restaurant.orderPizza("mushrooms", "spinach");
```

3. Nullish coalescing operator (??)
   - It's similar to ||, but nullish coalescing operator works with nullish values, but not falsy values.
   - Nullish values: only null and undefined (NOT 0 or '')

```js
restaurant.numGuests = 0;
const guestCorrect = restaurant.numGuests ?? 10;
console.log(guestCorrect); // 0
```

### 3.6 Logical assignment operators

- Logical operators can be used with assignment operators
- Logical operators can be used with any data type, and they can return any data type, not only boolean. They can also short circuit the evaluation of any expression.

```js
restaurant.numGuests = 20;
let guests = restaurant.numGuests || 10;
console.log(guests); // 10
restaurant.numGuests = 0;
// we can use logical operators with assignment operators

console.log(restaurant.numGuests); // 0
// or assignment operator: assign the right value if the left value is falsy
restaurant.numGuests ||= 10; // 10

// nullish coalescing assignment operator: assign the right value if the left value is nullish
restaurant.numGuests ??= 10; // 0, because 0 is not nullish

// and assignment operator: assign the right value if the left value is truthy
restaurant.numGuests &&= 10; // 0
```

\

### 3.7 The for-of Loop

- The for-of loop is a new loop introduced in ES6, and it's used for iterating over all iterables, such as arrays, strings, maps, and sets.
- we are able to still use break and continue statements in the for-of loop

```js
const menu = [...restaurant.starterMenu, ...restaurant.mainMenu];
// for-of loop
for (const item of menu) console.log(item);
// to get the index in the for-of loop, we can use the entries() method, it returns an array with the index and the element for iterables
for (const item of menu.entries()) console.log(item);
// we can destructure in the for-of loop
for (const [index, element] of menu.entries())
  console.log(`${index + 1}: ${element}`);
```

### 3.8 Enhanced Object Literals

- If we want to add a new property to an object with an existing object as the value, we can use the object literal syntax

```js
const openingHours = {
  thu: {
    open: 12,
    close: 22,
  },
  fri: {
    open: 11,
    close: 23,
  },
  sat: {
    open: 0, // Open 24 hours
    close: 24,
  },
};

const restaurant = {
  name: "BigWay",
  // we can just use the variable name, and it will be automatically converted to the same property name and assign the value of the variable to the property
  openingHours,
};
```

- We can also remove the semi-colon and the colon in the object literal for function attributes

```js
const restaurant = {
  // it's still the attribute of `order`, but we don't need to specify the key and the value
  order(starterIndex, mainIndex) {
    return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];
  },
};
```

- We can compute property names in the object literal

```js
const weekdays = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"];
const openingHours = {
  [weekdays[3]]: {
    open: 12,
    close: 22,
  },
  [weekdays[4]]: {
    open: 11,
    close: 23,
  },
  [`day-${2 + 4}`]: {
    open: 0, // Open 24 hours
    close: 24,
  },
};
```

### 3.9 Optional Chaining (?.)

- The optional chaining operator is used to check if a certain property exists in an object. Only if it exists, then it will read the property. If it doesn't exist, it will return undefined immediately. It helps us to get rid of the errors because of the missing properties.

```js
// we can use the optional chaining operator and the nullish coalescing operator together
const open = restaurant.hours[day]?.open ?? "closed";
```

- We can use optional chaining for checking if a function exists in an object before calling it

```js
console.log(restaurant.order1?.(0, 1) ?? "Method does not exist");
```

- Optional chaining also works on arrays

```js
const users = [{ name: "Echo", email: "echoooo1996@gamil.com" }];
console.log(users[0]?.email ?? "user not found!");
```

### 3.10 Looping Objects: Object Keys, Values, and Entries

- We can get keys of an object using `Object.keys()`, and it returns an array of the keys

```js
// property keys
const properties = Object.keys(restaurant.hours);
console.log(properties);
let openStr = `we will open on ${properties.length} days: `;
for (const day of Object.keys(restaurant.hours)) openStr += day + " ";
```

- We can get values of an object using `Object.values()`, and it returns an array of the values

```js
const values = Object.values(restaurant.hours);
```

- We can also get both keys and values of an object using `Object.entries()`, and it returns an array of arrays, each array contains the key and the value of the property

```js
// entries [key-value pairs], getting array of arrays of length 2
const entries = Object.entries(restaurant.hours);
// we can destructure the array of arrays immediately in the for-of loop
for (const [day, { open, close }] of entries)
  console.log(`on ${day}, we open at ${open}, we close at ${close}`);
```

### 3.10 Sets

- A collection of unique values
- It can hold different daya types;

```js
const orderSet = new Set("Pasta", "Piza", "Pizza");
console.log(orderSet); // Set(2) {"Pasta", "Pizza"}
console.log(orderSet.size); // 2
console.log(orderSet.has("Pizza")); // true, works similar as the includes() method of arrays
orderSet.add("Garlic Bread");
orderSet.delete("Pasta");
```

- There is no index in sets, so we cannot get elements from sets using index
- We can use the for-of loop to loop over the elements in the set like any other iterable

```js
const staff = ["Waiter", "Chef", "Waiter", "<Manager", "Chef", "Waiter"];
const staffUnique = [...new Set(staff)]; // we can use the spread operator to convert the set to an array
console.log(staffUnique); // Set(3) {"Waiter", "Chef", "<Manager"}
console.log(new Set(staff).size); // 3
// we can also count the number of unique characters in a string
console.log(new Set("jonasschmedtmann").size); // 11
```

### 3.11 Maps

1. Maps: fundamentals

- A map is stored in key-value pairs, and it's similar to objects, but the keys can have any data type, and we can use any data type as the key. In objects, the keys are always **strings**.
- set() method: add new key-value pairs to the map, and it returns the map itself, so we can chain the set() method.

```js
const rest = new Map();
rest
  .set("open", 11)
  .set("close", 23)
  .set(true, "we are open")
  .set(false, "we are closed");

const time = 8;
// smart yet not so readable
console.log(rest.get(time > rest.get("open") && time < rest.get("close")));
```

- get(), delete(), and has() methods

```js
console.log(rest.get("open")); // 11
console.log(rest.get(true)); // we are open
rest.delete(false); // just specify the key
console.log(rest); // Map(3) {"open" => 11, "close" => 23, true => "we are open"}
console.log(rest.has(false)); // false
console.log(rest.size); // 3
```

- When we are using array as keys, we should use a variable to store the array instead of the array literal: because the array literal is not the same array in the heap, and it will not work as the key.

```js
const arr = [1, 2];
rest.set(arr, "test");
console.log(rest.get(arr)); // test
console.log(rest.get([1, 2])); // undefined
```

- We can also use maps on DOM elements

```js
rest.set(document.querySelector("h1"), "Heading");
```

2. Maps: iteration

- Maps has a similar structure (array of arrays) with the entries() method of objects, so we can convert an object to a map using the entries() method easily

```js
const map = new Map(Object.entries(ourObject));
```

- We can also convert a map to an array using the spread operator

```js
// we can use the map object to call the entries() method (unlike the object, we need to use Object.entries() as it's static)
console.log([...question]);
console.log([...question.entries()]);
console.log([...question.keys()]);
console.log([...question.values()]);
```

### 3.12 Which Data Structure to Use?

> Sources of data

- From the program itself: written directly in the source code
- From the UI (DOM, other events)
- From external sources: data fetched from wev APIs, data stored in files, etc.

If we want a simple list => use an array or a set
If we want key-value pairs => use an object or a map

> But how to decide whether to use an array or a set, or an object or a map?
> **Arrays and Sets**

- Use arrays when you need ordered list of values, and when you need to manipulate data
- Use sets when you need to work with unique values, and when high-performance is really important, and when you need to remove duplicates

**Objects and Maps**

- Objects: more traditional key/value store, easier to write and access values with . and [], and when we need to include functions(methods)
  - Use when you need to include functions/ methods as values
  - Use when working with JSON (can convert between objects and JSON)
- Maps: better performance, keys can have any data type, easy to iterate, easy to compute size, and when we simply need to map key to values
  - Use when you simply need to map key to values
  - Use when you need keys that are not strings

### 3.13 Work with Strings

1. slice(), indexOf(), lastIndexOf(), indices start from 0

```js
const airline = "TAP Air Portugal";
const plane = "A320";

console.log(plane[0]);
console.log(plane[1]);
console.log(plane[2]);
console.log("B737"[0]);

console.log(airline.length);
console.log("B737".length);

console.log(airline.indexOf("r")); // will give us the first index
console.log(airline.lastIndexOf("r"));
console.log(airline.indexOf("Air"));
console.log(airline.indexOf("air")); // will return -1 for it's case-sensitive

console.log(airline.slice(4)); // it's the position where the slice method starts -> slice method returns a new string
console.log(airline.slice(4, 7)); // the length is 7-4, left inclusive and right exclusive

console.log(airline.slice(0, airline.indexOf(" ")));
console.log(airline.slice(airline.lastIndexOf(" ") + 1));

console.log(airline.slice(-2)); // cuts off the last 2 characterss
console.log(airline.slice(1, -1)); // cuts off the last character, from the second to the one before the last

const checkMiddleSeat = function (seat) {
  // B and E are middle seats
  const s = seat.slice(-1);
  if (s === "B" || s === "E") console.log("You got the middle seat😢");
  else console.log("You are lucky😄");
};
checkMiddleSeat("11B");
checkMiddleSeat("14F");
```

- String is primitive type, yet When we call methods with string, JS behind the sence converts the primitive String to String objects: this process is called 'Boxing'
- After the methods being executed, the String objects will be converted back to primitive String again

2. toLowerCase(), toUpperCase(), trim(), replace()

- trim() would remove all the white spaces at the beginning and the end of the string
- trimStart() and trimEnd() are the new methods introduced in ES10, which would specificly remove the white spaces at the beginning or the end of the string

```js
// Fix capitalization in name
const passenger = "eCHo"; //Echo
const passengerLower = passenger.toLowerCase();
const passengerCorrect =
  passengerLower[0].toUpperCase() + passengerLower.slice(1);
console.log(passengerCorrect);

// Comparing emails
const email = "hello@echo.io";
const loginEmail = "  Hello@Echo.IO  \n";
const normalizedLoginEmail = loginEmail.toLowerCase().trim();
console.log(email === normalizedLoginEmail);
```

- replace() creates a new string without mutating the original string
- replace() only replaces the first match, we can use replaceAll() to replace all the matches
- We can also use regular expressions in replace() to replace all the matches

```js
const announcement =
  "All passengers come to the boarding door 23. Boarding door 23!";

// console.log(announcement.replaceAll('door', 'gate'));

console.log(announcement.replace(/door/g, "gate"));
```

3. methods returns boolean

- includes()
- startsWith()
- endsWith()

```js
const plane = "Airbus A320neo";
console.log(plane.includes("A320")); // true
console.log(plane.includes("Boeing")); // false
console.log(plane.startsWith("Air")); // true

if (plane.startsWith("Airbus") && plane.endsWith("neo")) {
  console.log("Part of the NEW Airbus family");
}
```

4. padStart(), padEnd(), and repeat()

- The first argument is the length of the new string, the second argument is the string that we want to pad

```js
const message = "Go to gate 23!";
console.log(message.padStart(25, "+").padEnd(30, "+"));
console.log("Echo".padStart(25, "+").padEnd(30, "+"));
// ++++++++++++Go to gate 23!++
// +++++++++++++++++++++Echo++
```

- We can use pad methods easily to mask credit card numbers

```js
const maskCreditCard = function (number) {
  const str = number + "";
  const last = str.slice(-4);
  return last.padStart(str.length, "*");
};

console.log(maskCreditCard(123456789)); // ******6789
```

- repeat() method

```js
const message2 = "Bad weather... All Departures Delayed... ";
console.log(message2.repeat(5));
```

### Coding Challenge #4

```js
document.body.append(document.createElement("textarea"));
document.body.append(document.createElement("button"));

document.querySelector("button").addEventListener("click", () => {
  const text = document.querySelector("textarea").value;
  const words = text.split("\n");
  for (let [index, word] of words.entries()) {
    word = word.trim().toLowerCase();
    word =
      word.slice(0, word.indexOf("_") + 1) +
      word.slice(word.indexOf("_") + 1, word.indexOf("_") + 2).toUpperCase() +
      word.slice(word.indexOf("_") + 2);
    word = word.replace("_", "").padEnd(20, " ") + "✅".repeat(index + 1);
    console.log(word);
  }
});
```

## 4. Functions

### 4.1 Default Parameters

- We can specify defauly values of parameters in the function declaration
- but if we want to calculate the default value based on other parameters, we can only use parameter before the current parameter

```js
const bookings = [];
const createBooking = function (
  flightNum = "CA123",
  numPassenger = 1,
  // we can only use parameters defined in the list before price
  price = 199 * numPassenger
) {
  // numPassenger = numPassenger || 1;
  // price = price || 199;
  const booking = {
    flightNum,
    numPassenger,
    price,
  };
  console.log(booking);
  bookings.push(booking);
};

createBooking("LH123");
createBooking("LH123", 2);
```

- Also, we cannot skip parameters, we can only pass undefined to skip a parameter

### 4.2 Passing arguments

- For primitive values, we pass a copy of the value into the function, so the original value will not be changed
- For objects, we pass the reference of the object into the function, so when we manipulate the object within our function, the original object will also be changed

> Passing by value vs. passing by reference
> Javascript is a pass by value language, and has no pass by reference, even the reference of the object is passed by value (the address value)

### 4.3 First-Class and Higher-Order Functions

> First-Class Functions

- First-class function does not exist in practical, it's a concept in programming language theory, unlike higher-order functions, which is a practical concept.
- Functions are first-class citizens in JS, which means that functions are simply values.
- We can store functions in variables or object properties, and also pass functions as parameters of another function, also return a function from another function.
- We can ven call methods on functions

> Higher-Order Functions

- A function that receives another function as an argument, that returns a new function, or both
  - Examples of receiving other function: addEventListener, setTimeout, setInterval, forEach, map, filter, reduce, find, etc.
  - Examples of returning a new function: bind, filter, etc.

### 4.4 Functions Accepting Callback Functions

Callback means a function we don't need to call it ourselves, but pass it as an argument to another function, and then the other function will call it when it finishes its job.

- addEventListener() is a higher-order function, and the callback function is the event handler

```js
const oneWord = function (str) {
  return str.replace(/ /g, "").toLowerCase();
};

const upperFirstWord = function (str) {
  const [first, ...others] = str.split(" ");
  return [first.toUpperCase(), ...others].join(" "); // print the new array as a string
};

// Higher-order function
const transformer = function (str, fn) {
  console.log(`transformed string: ${str}`);
  console.log(`transformed string: ${fn(str)}`);
  console.log(`transformed string: ${fn.name}`);
};
```

- Callback functions allow us to create abstraction. E.g., the transformer function doesn't need to know how the string is transformed, it just needs to know that it will be transformed by the callback function.
- forEach()

```js
const high5 = function () {
  console.log("👋");
};
```

### 4.5 Functions Returning Functions

The opposite of callback functions, we return a function from another function.

```js
const greet = function (greeting) {
  return function (name) {
    console.log(`${greeting} ${name}`);
  };
};

// calling the function returns a function, which we can assign to another variable, and then call with the new variable
const greeterHey = greet("hey");

greeterHey("Echo");

// a simpler way
greet("Hello")("Echo"); // coz greet("Hello") returns a function, and we can call the function immediately

// a shorter way of one arrow function returning another arrow function
const greet = (greeting) => (name) => console.log(`${greeting} ${name}`);
```

Might seem weird now, but it's very useful in functional programming.

### 4.6 The call and apply Methods

- What do we do if we wanna call a method from another object? We can isolate the method to be a function, but how to set the `this` keyword to the object we want?

```js
const lufthansa = {
  airline: "Lufthansa",
  iataCode: "LH",
  bookings: [],
  book(flightNum, name) {
    console.log(`${name} booked a seat on ${this.iataCode}${flightNum}`);
    this.bookings.push({ flight: `${this.iataCode} ${flight}`, name });
  },
};

lufthansa.book(352, "Echo Wang");
lufthansa.book(123, "Ermao Wang");

const eurowings = {
  airline: "Eurowings",
  iataCode: "EW",
  bookings: [],
};

const book = lufthansa.book; // it's a copy of a method, but became a function, so the 'this' keyword is now pointing to 'undefined'
book(23, "Sarah Williams"); // Uncaught TypeError: Cannot read property 'iataCode' of undefined
```

- We have call(), apply() to set the `this` keyword (`call()` is more used)
- Instead of calling the book function, we call a method on it, and the method would call the function with teh first argument of call() method (which is the object that we want to set the `this` keyword to), and the rest of the arguments are the arguments of the function.

```js
book.call(eurowings, 23, "Echo Wang"); // the first parameter is the object that we want to set the `this` keyword to, and the rest of the parameters are the arguments of the function
book.apply(eurowings, [23, "Echo Wang"]); // apply() method takes an array of arguments
```

- bind() method: similar to call() method, but it does not immediately call the function, but instead returns a new function where the `this` keyword is bound.

```js
// we use bind() to create a new function with the `this` keyword set to eurowings, and call the new function
const bookEW = book.bind(eurowings);
const bookLH = book.bind(lufthansa);
const bookLX = book.bind(swiss);
bookEW(235, "Dapang");

// we can also take one step furtuer: we can set the second argument of bind() method to set the first argument of the function
const bookEW23 = book.bind(eurowings, 23);
// when we call the new function, we only need to pass the second argument
bookEW23("Echo Wang");
```

- Use `this` with event listeners, we need to define the `this` keyword in the function, coz the `this` keyword is set to the element that the handler is attached to.

```js
// with event listeners
lufthansa.planes = 300;
lufthansa.buyPlane = function () {
  this.planes++;
  console.log(this.planes);
};

document.querySelector(".buy").addEventListener("click", lufthansa.buyPlane); // the `this` keyword is set to the button element, not the lufthansa object
// `this` keyword is always set to the element that the handler is attached to

document
  .querySelector(".buy")
  .addEventListener("click", lufthansa.buyPlane.bind(lufthansa)); // we can use bind() method to set the `this` keyword to the lufthansa object and return a new function, then call the function with the event handler
```

- Partial application: a technique that we create a function based on another function, but with some preset parameters

```js
// partial application: pre-set parameters
const addTax = (rate, value) => value + value * rate;
console.log(addTax(0.1, 200));

const addVAT = addTax.bind(null, 0.23); // we don't need to set the `this` keyword, so we set it to null
console.log(addVAT(100));
```

It works the same as returning function within a function (higher-order function)

```js
const addTaxRate = rate => {
  return value => {
    reutrn value + value * rate;
  }
}

const addVAT2 = addTaxRate(0.23);
console.log(addVAT2(100));
```

### 4.7 Immediately Invoked Function Expressions (IIFE)

Sometimes we need a function that is only executed once, and then never again. We can use IIFE to do that.

```js
// only write the function expression without assigning it to a variable
// we trick the browser by wrapping the expression in parentheses, coz the browser thinks that anything inside parentheses is an expression
// don't forget the parentheses at the end of the function expression
(function () {
  console.log("This will never run again");
})();
```

Also works for arrow functions

```js
(() => console.log("This will ALSO never run again"))();
```

In IIFE, all the variables are private, or encapsulated, coz they are scoped to the function, and not accessible from the outside. but in modern JS, block scope is more common.

```js
(() => {
  let test = 23;
  console.log(`IIFE: ${test}`);
})();
```

### 4.8 Closures

Basically, a function can have access to the variable environment of the execution context in which it was **created**. Even after that execution context is gone.

```js
const secureBooking = function () {
  let passengerCount = 0;

  return function () {
    passengerCount++;
    console.log(`${passengerCount} passengers`);
  };
};
const booker = secureBooking();
booker(); // 1 passengers
booker(); // 2 passengers
// even after the secureBooking() function has returned, the booker() function still has access to the passengerCount variable
```

- after the execution context of secureBooking() function is gone, the variable environment is still stored in the closure
- the closure has priority over the scope chain. The browser will first look for the variable in the closure, and then the scope chain.
- A closure makes sure that a function doesn't lose connection to variables that existed at the function's birth place.
- A closure is like a backpack that a function carries around wherever it goes. This backpack has all the variables that were present in the environment where the function was created. It's not something can be directly accessed, but an internal functionality, it's always there.
- we can check it by `console.dir(booker)`, and we can see the [[Scopes]] property, which is the closure.

We don't have to let function return another function to create a closure, we can also create a closure by assigning and reassiging a function to a variable.

```js
// Example 1
let f;
const g = function () {
  const a = 23;
  f = function () {
    console.log(a * 2);
  };
};
g();
f(); // 46
// even after the execution context of g() function is gone, the f() function still has access to the variable environment of g() function, coz the f() function is a closure

// take it to the next level
// a function can be "reborn" by assigning it to another variable
const h = function () {
  const b = 777;
  f = function () {
    console.log(b * 2);
  };
};
g();
f(); // 46
h();
f(); // 1554 // it has the closure where it is last defined

// Example 2
// after 1000 ms, the execution context of boardPassengers() function is gone, but the callback function still has access to the variable environment of boardPassengers() function within its closure
const boardPassengers = function (n, wait) {
  const perGroup = n / 3;
  setTimeout(function () {
    console.log(`We are now boarding all ${n} passengers`);
  }, 1000);
};
const perGroup = 1000;
// still, the callback function would use the perGroup variable in the closure, not the global variable, because the closure has priority over the scope chain
```

## 5. Working with Arrays

### 5.1 Simple Array Methods

- slice(): returns a new array, it does not mutate the original array

```js
let arr = ["a", "b", "c", "d", "e"];
arr.slice(2); // ["c", "d", "e"]
console.log(arr); // ["a", "b", "c", "d", "e"]
console.log(arr.slice(-2)); // ["d", "e"]
console.log(arr.slice(1, -2)); // ["b", "c"], starts from index 1, and ends at index -2, but not including index -2
console.log(arr.slice(-2)); // ["d", "e"], starts from index -2, and ends at the end of the array
console.log(arr.slice()); // ["a", "b", "c", "d", "e"], returns a shallow copy of the array
console.log([...arr]); // works the same as arr.slice()
```

- splice(): works like slice(), but mutates the original array

```js
arr.splice(2); // ["c", "d", "e"], returns the removed elements
console.log(arr); // ["a", "b"] there are only 2 elements left in the array, which are not spliced out
arr.splice(-1); // remove the last element
console.log(arr); // ["a"]
arr = ["a", "b", "c", "d", "e"];
arr.splice(1, 2); // the 2nd parameter is the number of elements to be removed
```

- reverse(): mutates the original array

```js
arr = ["a", "b", "c", "d", "e"];
const arr2 = ["j", "i", "h", "g", "f"];
console.log(arr2.reverse()); // ["f", "g", "h", "i", "j"]
console.log(arr2); // ["f", "g", "h", "i", "j"]
```

- concat(): does not mutate the original array

```js
const letters = arr.concat(arr2);
console.log(letters); // ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"]
console.log([...arr, ...arr2]); // spread and join the 2 arrays // works the same as arr.concat(arr2)
```

- join(): does not mutate the original array, return a string with the elements joined by the separator

```js
console.log(letters.join(" - ")); // a - b - c - d - e - f - g - h - i - j
```

### 5.2 the new at the ES6

```js
const arr = [23, 11, 64];
console.log(arr[0]);
console.log(arr.at(0)); // we can replace the traditional bracket notation with the new at() method
```

- It's particular useful when we want to get the last element/ count from the end of the array

```js
console.log(arr[arr.length - 1]);
console.log(arr.slice(-1)[0]); // returns a new array, and we need to get the first element of the new array, works the same as arr.at(-1)
console.log(arr.at(-1)); // much more concise
```

- at() method also works with strings

```js
console.log("Jonas".at(0)); // J
```

### 5.3 Looping Arrays: forEach()

- Unlike for-of, forEach() method is a higher-order function, it takes a callback function as its parameter. And it is the forEach() method, instead of ourselves, that calls the callback function.
- We can pass each element, the index, and the whole array to the callback function as its parameters.

```js
movements.forEach(function (movement) {
  if (movement > 0) {
    console.log(`You deposited ${movement}`);
  } else {
    console.log(`You withdrew ${Math.abs(movement)}`);
  }
});

// we can also pass the index and the whole array to the callback function
movements.forEach(function (movement, index, array) {
  // the order of the parameters matters
  if (movement > 0) {
    console.log(`Movement ${index + 1}: You deposited ${movement}`);
  } else {
    console.log(`Movement ${index + 1}: You withdrew ${Math.abs(movement)}`);
  }
});

// we can also use for-of loop to loop through the array, but need to destruct the array of entries, and the order of the destructed array is different from the forEach() method
for (const [index, movement] of movements.entries()) {
  if (movement > 0) {
    console.log(`Movement ${index + 1}: You deposited ${movement}`);
  } else {
    console.log(`Movement ${index + 1}: You withdrew ${Math.abs(movement)}`);
  }
}
```

- forEach() method cannot break or continue the loop, it will always loop through the whole array

### 5.4 forEach() with Maps and Sets

- When we call forEach() method for a map, it will pass 3 parameters to the callback function: (value, key, map), which are corresponding to the parameters of forEach() method for an array: (element, index, array)

```js
const currencies = new Map([
  ["USD", "United States dollar"],
  ["EUR", "Euro"],
  ["GBP", "Pound sterling"],
]);
currencies.forEach(function (value, key, map) {
  console.log(`${key}: ${value}`);
});
```

- And for a set, the callback function will still have 3 parameters,but the key is the same as the value, because a set does not have keys

```js
const currenciesUnique = new Set(["USD", "GBP", "USD", "EUR", "EUR"]);
console.log(currenciesUnique);
currenciesUnique.forEach(function (value, key, map) {
  console.log(`${key}: ${value}`);
}); // the key is the same as the value
```

### 5.5 Creating DOM elements

- It's always the best practice to wrap code within a function, instead of writing the code directly in the global scope
- insertAdjacentHTML() method: accept 2 strings as its parameters, the first one is the position, and the second one is the HTML string
  - If we use beforeend with a forEach() to loop through the array, the elements will be added in the same order as they are in the array
  - On the contrary, if we use afterbegin, the elements will be added in the reverse order as they are in the array

```html
<!-- before begin -->
<p>
  <!-- after begin -->
  foo
  <!-- before end -->
</p>
<!-- after end -->
```

- empty a container: container.innerHTML = '';
- it's great to create DOM elements with literal templates

```js
const displayMovements = function (movements) {
  containerMovements.innerHTML = "";
  movements.forEach(function (mov, i) {
    const type = mov > 0 ? "deposit" : "withdrawal";
    const html = `        
    <div class="movements__row">
      <div class="movements__type movements__type--${type}">${
      i + 1
    } ${type}</div>
      <div class="movements__value">${mov}€</div>
    </div>`;
    containerMovements.insertAdjacentHTML("afterbegin", html);
  });
};
```

### 5.6 Data Transformations: map(), filter(), reduce()

- map(): returns a new array containing the results of applying an operation on all original array elements, quite similar to forEach() method, but the difference is that map() method returns a new array, instead of mutating the original array

💡 map() can also take the same 3 parameters as forEach() method: (element, index, array)

```js
const eurToUsd = 1.1;
// it's nice we can write the callback function in one line with arrow functions
const movementsUSD = movements.map((mov) => mov * eurToUsd);

const movementsDescriptions = movements.map((mov, i) => {
  return `Movement ${i + 1}: You ${
    mov > 0 ? "deposited" : "withdrew"
  } ${Math.abs(mov)}`;
});

// the main difference between map() and forEach() is that map() returns a new array, instead of mutating the original array, and forEach() can do some mutation without returning anything
const createUsernames = function (accs) {
  // forEach() is used to add a new property to each element of the array
  accs.forEach((acc) => {
    acc.username = acc.owner
      .toLowerCase()
      .split(" ")
      // map is used to return a new array for further joining
      .map((name) => name[0])
      .join("");
  });
};

createUsernames(accounts);
```

- filter(): returns a new array containing the array elements that passed a specified test condition

```js
const deposits = movements.filter((mov) => mov > 0);
```

- reduce(): boils ("reduces") all array elements down to one single value (e.g. adding all elements together). It's not limited to sum, we can do anything with reduce() method, such as calculating the maximum value, or the average value, etc.

💡 Unlike forEach(), map() or filter(), reduce takes 4 parameters in the callback function: (accumulator, current element, index, array), and inside the callback function, and a second parameter after the callback function, which is the initial value of the accumulator

```js
const balance = movements.reduce((acc, cur) => {
  console.log(`iteration ${i}: ${acc}`);
  return acc + cur;
}, 0);

// get the maximum value
const max = movements.reduce(
  // in each iteration, we return teh bigger one, and the bigger one will be the accumulator in the next iteration
  (acc, mov) => (acc > mov ? acc : mov),
  // we need to set the initial value of the accumulator to the first element of the array, instead of 0
  movements[0]
);
console.log(max);
```

### 5.7 The Magic of Chaining Methods

Using the 3 methods in chaining is like a pipeline, and the order of the methods is important, because the output of the previous method will be the input of the next method

```js
const totalDepositsUSD = movements
  .filter((mov) => mov > 0)
  .map((mov) => mov * eurToUsd)
  .reduce((acc, mov) => acc + mov, 0);
console.log(totalDepositsUSD);
// and if we wanna debug the code, we can always use the array parameter in the callback function of each method
```

### 5.8 find() method

- find() method is used to find the first element in the array that satisfies the condition, unlike filter(), which returns a new array containing all the elements that satisfy the condition
- Also, if the found element is an object, we can directly use the dot notation to access its properties because we're getting the element itself, ratehr than a copy of the element

```js
console.log(accounts);
const account = accounts.find((acc) => acc.owner === "Jessica Davis"); // once the condition is satisfied, the find() method will stop the iteration and return the element
console.log(account); // {owner: "Jessica Davis", movements: Array(8), interestRate: 1.5, pin: 2222, username: "jd"}
```

### 5.9 findIndex() method

- findIndex() method is used to find the index of the first element in the array that satisfies the condition, unlike find(), which returns the element itself
- it works quite similar like indexOf(), but it takes a callback function as its parameter, instead of a value, and also it can work in both arrays and objects

```js
if (
    inputCloseUsername.value === currentAccount.username &&
    Number(inputClosePin.value) === currentAccount.pin
  ) {
    const index = accounts.findIndex(
      acc => acc.username === currentAccount.username
    );
    accounts.splice(index, 1);
```

### 5.10 includes(), some() and every() methods

- includes() can check if an array includes a certain value, and it returns a boolean value
- some() checks if at least one element in the array satisfies the condition, and it returns a boolean value
- every() checks if all the elements in the array satisfy the condition, and it returns a boolean value

💡 The main difference is: includes() can only check equality, but some() and every() can check any condition

```js
// SOME: if any element in the array satisfies the condition, then return true
if (amount > 0 && currentAccount.movements.some((mov) => mov >= amount * 0.1)) {
  currentAccount.movements.push(amount);
  updateUI(currentAccount);
  inputLoanAmount.value = "";
}
// EVERY: if every element in the array satisfies the condition, then return true
console.log(account4.movements.every((mov) => mov > 0)); // prints true because all the elements are positive

// Separate callback
const deposit = (mov) => mov > 0;
console.log(account4.movements.some(deposit)); // prints true
```

### 5.11 flat() and flatMap() methods

- flat() method is used to flatten nested arrays into one single array, it only goes one level deep, and it can take a parameter to specify the depth of the nested arrays

```js
const arr = [[1, 2, 3], [4, 5, 6], 7, 8];
console.log(arr.flat()); // [1, 2, 3, 4, 5, 6, 7, 8]
const arrDeep = [[[1, 2], 3], [4, [5, 6]], 7, 8];
console.log(arrDeep.flat()); // [Array(2), 3, 4, Array(2), 7, 8]

// the depth parameter
console.log(arrDeep.flat(2)); // [1, 2, 3, 4, 5, 6, 7, 8]

// In practice: it's a common use case to first map() and then flat()
const accountMovements = accounts
  .map((acc) => acc.movements)
  .flat()
  .reduce((acc, mov) => acc + mov, 0); // 17840
```

- flatMap() method is used to combine map() and flat() methods together, and it only goes one level deep

❕ flatMap() only goes one level deep, so if we have a nested array inside a nested array, we still need to use flat() method

```js
const accountMovements = accounts
  .flatMap((acc) => acc.movements)
  .resuce((acc, mov) => acc + mov, 0);
```

### 5.12 Sorting Arrays

- `sort()` method is used to sort the elements in the array, and it **❗️mutates** the original array, so use slice() method to create a copy of the array before sorting it
- `sort()` method does the sorting by converting all the elements into **strings**, and then compare the strings alphabetically: to handle this, we pass a callback function as the parameter of the `sort()` method, and in the callback function, we can specify the sorting condition

```js
// compare numbers in ascending order
movements.sort((a, b) => a - b);
// compare numbers in descending order
movements.sort((a, b) => b - a);
```

### 5.13 More Ways of Creating and Filling Arrays

- fill() method is used to fill the array with a certain value, and it mutates the original array

```js
const x = new Array(7); // [empty × 7]
x.fill(1); // [1, 1, 1, 1, 1, 1, 1]
// the 2nd and 3rd parameters are the start and end index
x.fill(1, 3); // [empty × 3, 1, 1, 1]
x.fill(1, 3, 5); // [empty × 3, 1, 1, empty × 2]
// fill() can also mutate an existing array
const arr = [1, 2, 3, 4, 5, 6, 7];
arr.fill(23, 2, 6); // [1, 2, 23, 23, 23, 23, 7]
```

- Array.from() method. 1st parameter: the length of the array, 2nd parameter: a callback function that returns the value of each element in the array

```js
Array.from({ length: 7 }, () => 1); // [1, 1, 1, 1, 1, 1, 1]

// works like map()
const z = Array.from({ length: 7 }, (_, i) => i + 1); // [1, 2, 3, 4, 5, 6, 7]

// create 100 random dice rolls
const diceRolls = Array.from({ length: 100 }, () =>
  Math.trunc(Math.random() * 6 + 1)
);
```

- we can also use Array.from() method to convert a NodeList from the DOM into an array

```js
labelBalance.addEventListener("click", () => {
  const movementsUI = Array.from(
    document.querySelectorAll(".movements__value"),
    (el) => Number(el.textContent.replace("€", ""))
  );

  console.log(movementsUI);
});

// or use spread operator
const movementsUI2 = [...document.querySelectorAll(".movements_value")].map(
  (el) => Number(el.textContent.replace("€", ""))
);
```

### 5.14 Summary: Array Methods Practice

> ❓ Which array method should we use in each situation?

There are many different scenarios:

- to mutate the original array
  |add to original array|remove from original array|other|
  |---|---|---|
  |push()|pop()|reverse()|
  |unshift()|shift()|sort()|
  |splice()|splice()|fill()|

- to get a new array
  | compute from original | filter | portion | concat | flatten|
  |---|---|---|---|---|
  | map() | filter() | slice() | concat() | flat() |
  |||||flatMap()|
- to get the index of an element
  |based on value|based on condition|
  |---|---|
  |indexOf()|findIndex()|
- know if an array includes a certain value: returns a boolean
  | based on value | based on condition |
  |---|---|
  | includes() | some() |
  ||every()|
- to transform to a value: `reduce()`
- to get an array element: `find()`
- to get a new string:` join()`
- to just loop over an array: `forEach()` -- does not create a new array or any value

### 5.15 Array Methods Practice

We can use `reduce()`method not only for numbers, but also initialize an object and mutate it in the callback function

```js
const { deposits, withdraws } = accounts
  .flatMap((acc) => acc.movements)
  .reduce(
    (sums, cur) => {
      // cur > 0 ? (sums.deposits += cur) : (sums.withdraws += Math.abs(cur));
      sums[cur > 0 ? "deposits" : "withdraws"] += cur;
      return sums;
    },
    { deposits: 0, withdraws: 0 }
  );
console.log(deposits, withdraws);
```

## 6. Numbers, Dates, Intl and Timers

### 6.1 Converting and Checking Numbers

> 💡 In javascript, all numbers are represented internally as floating point numbers. That's why we only have one data type for numbers in JS

- Numbers are represented as 64-bits binary floating point numbers (IEEE 754 standard)

```js
console.log(23 === 23.0); // true
console.log(0.1 + 0.2); // 0.30000000000000004, because 0.1 and 0.2 cannot be represented exactly in binary floating point numbers
console.log(0.1 + 0.2 === 0.3); // false

// convert string to number
console.log(Number("23")); // 23, or easier, just a plus sign before the string
console.log(+"23"); // 23

// Parsing: useful for cases we we have extra characters in the string
console.log(Number.parseInt("30px")); // 30
// pass the base as the 2nd parameter
console.log(Number.parseInt("30px", 10)); // 30
console.log(Number.parseInt("30px", 2)); // NaN
// parse float
console.log(Number.parseFloat("2.5rem")); // 2.5
console.log(Number.parseInt("2.5rem")); // 2, stops at the decimal point

// isNaN() method
console.log(Number.isNaN(20)); // false
console.log(Number.isNaN("20")); // false
console.log(Number.isNaN(+"20X")); // true
console.log(Number.isNaN(23 / 0)); // false, but not accurate, it's a infinite value

// isFinite() method
console.log(Number.isFinite(20)); // true
console.log(Number.isFinite("20")); // false
console.log(Number.isFinite(+"20X")); // false
console.log(Number.isFinite(23 / 0)); // false, because it's infinite

// isInteger() method
console.log(Number.isInteger(23)); // true
console.log(Number.isInteger(23.0)); // true, 23.0 is still 23
console.log(Number.isInteger(23 / 0)); // false, because it's infinite
```

### 6.2 Math and Rounding

There are many useful methods and constants in the Math object

```js
// square root
console.log(Math.sqrt(25)); // 5
console.log(25 ** (1 / 2)); // 5
// cube root
console.log(8 ** (1 / 3)); // 2

// max and min
console.log(Math.max(5, 18, 23, 11, 2)); // 23
console.log(Math.max(5, 18, "23", 11, 2)); // 23

// area of a circle
console.log(Math.PI * Number.parseFloat("10px") ** 2); // 314.1592653589793

// random(returns a random number between 0 and 1), trunc(returns the integer part of a number)
console.log(Math.trunc(Math.random() * 6) + 1); // 1 ~ 6

// randomInt (returns a random integer between 2 numbers)
const randomInt = (min, max) => Math.floor(Math.random() * (max - min)) + min;
// Rounding integers
console.log(Math.trunc(23.3)); // 23, remove the decimal part
console.log(Math.round(23.3)); // 23, round to the nearest integer
console.log(Math.round(23.9)); // 24
console.log(Math.ceil(23.3)); // 24, round up
console.log(Math.ceil(23.9)); // 24
console.log(Math.floor(23.3)); // 23, round down
console.log(Math.floor(23.9)); // 23
// the difference between trunc() and floor(): when the number is negative, trunc() returns the next integer, but floor() returns the previous integer
console.log(Math.trunc(-23.3)); // -23
console.log(Math.floor(-23.3)); // -24

// Rounding decimals, boxing converts a primitive value to an object
console.log((2.7).toFixed(0)); // 3, returns a string
console.log((2.7).toFixed(3)); // 2.700
console.log((2.345).toFixed(2)); // 2.35, round up
console.log(+(2.345).toFixed(2)); // 2.35, convert the string to a number
```

### 6.3 The Remainder Operator

- `%` is the remainder operator, it returns the remainder of a division

```js
console.log(5 % 2); // 1
console.log(8 % 3); // 2
console.log(6 % 2); // 0
```

- It's a good practice to use remainer operator if we want to do something every n times

```js
labelBalance.addEventListener("click", () => {
  [...document.querySelectorAll(".movements__row")].forEach((row, i) => {
    if (i % 2 === 0) {
      row.style.backgroundColor = "orange";
    }
    if (i % 3 === 0) {
      row.style.backgroundColor = "blue";
    }
  });
});
```

### 6.4 Numeric separators

- From ES2021, we can use `_` to separate numbers, which is very useful for large numbers

```js
// the engine will ignore the underscores
const num = 100_000_000;
console.log(num); // 100000000
```

- We can not only use `_` in the thousands place, we can basically use it everywhere, except for the beginning or the end of a number, or before or after the decimal point
- We should not use `_` in a string, coz when we try to convert the string to a number, the engine will throw an error of NaN

### 6.5 Working with BigInt

- With 63 digits, there's a limit for the maximum number that can be represented in JS, which is 2^53 - 1, and if we want to represent a larger number, we can use BigInt
- to use BigInt, we need to add `n` at the end of the number

```js
console.log(48384302234234234234n); // 48384302234234234234n
console.log(BigInt(48384302234234234234)); // 48384302234234234234n

// calculations are the same rule, but we cannot mix BigInt with regular numbers
console.log(10000n + 10000n); // 20000n
console.log(48384302234234234234n * 100000n); // 4838430223423423423400000n
// division is different
console.log(10n / 3n); // 3n, it returns the integer part
// we can use comparison operators
console.log(20n > 15); // true
console.log(20n === 20); // false

// we can also do string concatenation
console.log(20n + " is really big"); // 20 is really big

// math methods don't work for BigInt
console.log(Math.sqrt(16n)); // TypeError: Cannot convert a BigInt value to a number
```

### 6.6 Creating Dates

- There are 4 ways to create a date

```js
// 1. create a date without any parameters
const now = new Date();
console.log(now); // Sun Aug 02 2020 17:50:41 GMT-0700 (Pacific Daylight Time)

// 2. create a date from a string: quiet unreliable, unless string is created by JS
const now = new Date("Aug 02 2020 18:05:41");
console.log(now); // Sun Aug 02 2020 18:05:41 GMT-0700 (Pacific Daylight Time)

// 3. create a date from a number
console.log(new Date(2037, 10, 19, 15, 23, 5)); // Tue Nov 19 2037 16:23:05 GMT-0700 (Pacific Daylight Time)
// javascript auto-correction
console.log(new Date(2037, 10, 31)); // Sun Dec 01 2037 00:00:00 GMT-0800 (Pacific Standard Time)
console.log(new Date(0)); // Thu Jan 01 1970 00:00:00 GMT-0800 (Pacific Standard Time)

// 4. create a date from a timestamp
console.log(new Date(3 * 24 * 60 * 60 * 1000)); // Sun Jan 04 1970 00:00:00 GMT-0800 (Pacific Standard Time)
```

- Working with dates

```js
// working with dates
const future = new Date(2037, 10, 19, 15, 23, 5); // Tue Nov 19 2037 16:23:05 GMT-0700 (Pacific Daylight Time)
console.log(future.getFullYear()); // 2037
console.log(future.getMonth()); // 10, November
console.log(future.getDate()); // 19
console.log(future.getDay()); // 2, Tuesday
console.log(future.getHours());
console.log(future.getMinutes());
console.log(future.getSeconds());
console.log(future.toISOString()); // 2037-11-20T00:23:05.000Z
```

- timestamps: the number of milliseconds that have passed since January 1st, 1970. We can get the timestamp of now by `Date.now()`

```js
// there are set methods for each of the get methods
future.setFullYear(2040);
// 🟡 getMonth() method returns the month index, so we need to add 1 to get the actual month

console.log(future); // Sat Nov 19 2040 16:23:05 GMT-0800 (Pacific Standard Time)
```

- toISOString() method returns a string in the ISO format

### 6.7 Operations With Dates

Timestamps are useful for calculating the difference between 2 dates

```js
const future = new Date(2037, 10, 19, 15, 23, 5); // Tue Nov 19 2037 16:23:05 GMT-0700 (Pacific Daylight Time)
// we can easily get the timestamp of a date by using the + operator
console.log(+future); // 2142245785000

const calcDaysPassed = (date1, date2) =>
  // we can get the date in milliseconds by using the getTime() method and then divide it by the number of milliseconds in a day
  Math.abs(date2 - date1) / (1000 * 60 * 60 * 24);

const formatMovementsDate = function (date) {
  const calcDaysPassed = (date1, date2) =>
    Math.abs(date1 - date2) / (1000 * 60 * 60 * 24);

  const daysPassed = Math.round(calcDaysPassed(date, new Date()));

  if (daysPassed === 0) return "Today";
  if (daysPassed === 1) return "Yesterday";
  if (daysPassed <= 7) return `${daysPassed} days ago`;
  else {
    // day/month/year
    const day = `${date.getDate()}`.padStart(2, 0);
    const month = `${date.getMonth() + 1}`.padStart(2, 0);
    const year = date.getFullYear();
    return `${day}/${month}/${year}`;
  }
};
```

### 6.8 Internationalizing Dates and Numbers (Intl)

We can simplyfy the formatting process by using the Intl object

```js
const now = new Date();
labelDate.textContent = new Intl.DateTimeFormat("en-CA").format(now);
// we can specify the options and pass it as the 2nd parameter
const options = {
  hour: "numeric",
  minute: "numeric",
  day: "numeric",
  month: "long",
  year: "numeric",
  weekday: "long",
};
```

- We can also use the navigator object to get the locale of the user's browser

```js
const locale = navigator.language;

labelDate.textContent = new Intl.DateTimeFormat("en-US", options).format(now);
```

- We can also format numbers with the Intl API: Intl.NumberFormat()

```js
const num = 3884764.23;
const options = {
  // for style, we can use unit, percent, currency
  // when the style is percent, the unit is ignored
  // when the style is currency, we need to specify the currency
  style: "currency",
  unit: "celsius",
  currency: "EUR",
  // useGrouping: false,
};
console.log("US: ", new Intl.NumberFormat("en-US", options).format(num)); // US:  $3,884,764.23
console.log("Germany: ", new Intl.NumberFormat("de-DE", options).format(num)); // Germany:  3.884.764,23 €
console.log("Syria: ", new Intl.NumberFormat("ar-SY", options).format(num));
```

### 6.9 Timers: setTimeout() and setInterval()

- setTimeout() method is used to run a callback function after a certain amount of time

```js
// we don't call the callback function, we just pass it as a parameter and wait the setTimeout() method to call it
setTimeout(() => console.log("Here is your pizza 🍕"), 2000);

// asynchronus callback function: the callback function will be called after the time interval, but the rest of the code will be executed immediately
console.log("Waiting...");

// We can actually pass parameters to the callback function after the time interval
const ingredients = ["olives", "spinach"];
const pizzaTimer = setTimeout(
  (ing1, ing2) => console.log(`Here is your pizza with ${ing1} and ${ing2}`),
  3000,
  ...ingredients
);

if (ingredients.includes("spinach")) clearTimeout(pizzaTimer);
```

- setInterval() method is used to run a callback function after a certain amount of time, and it will keep running the callback function after the specified time interval endlessly

```js
setInterval(function () {
  const now = new Date();
  console.log(now);
}, 1000); // it will keep running the callback function after 1 second

// if we want to call the first callback function immediately, we can call it before the setInterval() method
const tick = () => {
  const now = new Date();
  console.log(now);
};
tick();
setInterval(tick, 1000);

// it's a good idea to set a timer as a global variable, so we can clear it before it runs again
clearInterval(timer);
timer = startLogOutTimer(); // this function returns a new timer, and we can assign it to the global variable
```

## 7. Advanced DOM and Events

### 7.1 How the DOM Really Works

- DOM tree is composed of nodes, and we have 4 types of nodes: element nodes, text nodes, comment nodes, and document nodes

1. element nodes: HTML tags

- There are different types of elememnt depending on the tag name, different types have different attributes in the element object.

- Inheritance: There is a special type of node called event target, which is the parent of all the element nodes, so we can use event delegation to handle events in any element nodes

2. text nodes: the actual text
3. comment nodes: comments in the HTML code
4. document nodes: the entry point into the DOM

### 7.2 Selecting, Creating, and Deleting Elements

Selecting

- querySelectorAll(): returns a NodeList, which isn't live
- getElementByClassName() and getElementByTagName(): returns a HTMLCollection, which is live, meaning that it will be updated **automatically** when the DOM changes

Creating and inserting

- createElement(): create a new element, but it's only in the DOM, not in the HTML code

- insertAdjacentHTML(): insert a HTML string into the DOM
- append(): insert an element as the last child of another element
- prepend(): insert an element as the first child of another element

  💡 DOM element is unique, so we can use append() and prepend() to move an element from one place to another

```js
header.prepend(message);
header.append(message);
```

- before(): insert an element before another element
- after(): insert an element after another element
- remove(): remove an element from the DOM

### 7.3 Styles, Attributes and Classes

🎀 **Styles**

- We can add inline styles to an element by using the style property, and the value of the style property is a string, and we should use **camelCase** to write the CSS properties

```js
// Styles: inline styles
message.style.backgroundColor = "#37383d";
message.style.width = "120%";
```

- we can use getComputedStyle() method to get all the styles of an element

```js
console.log(message.style.height); // likely, it only loads inline styles
console.log(getComputedStyle(message).color); // this will return all the styles we want
```

- and we can use Number.parseFloat() to convert the string to a number, which is very useful for changing the height of an element

```js
message.style.height =
  Number.parseFloat(getComputedStyle(message).height, 10) + 30 + "px";
```

- We can also work with CSS properties(variables) with DOM manipulation
  > root is the :root pseudo-class, which is the same as the html tag

```js
// when we use documentElement, we're selecting the root element, which is the html tag
// setProperty() method takes 2 parameters: the name of the CSS property, and the value of the CSS property
document.documentElement.style.setProperty("--color-primary", "orangered");
```

🎩 **Attributes**

- Attributes means the attributes in the HTML code, such as id, class, src, etc. We can simply get attribute value by .attributeName. 🟡 Note this only works for standard attributes, not custom attributes

```js
// Attributes
const logo = document.querySelector(".nav__logo");
console.log(logo.alt); // Bankist logo
console.log(logo.src); // http://
console.log(logo.className); // nav__logo

// Non-standard attributes
console.log(logo.designer); // undefined
```

- getAttribute() method can get the value of a non-standard attribute, same for setAttribute() method

```js
console.log(logo.getAttribute("designer")); // Jonas
logo.setAttribute("company", "Bankist");
```

💡 Another main difference from dot and getAttribute():
the first one would return the absolute path of the image, but the second one would return the one in our html code, this also works for href attribute

- data attributes: we can use data attributes to store some data in the HTML code, and we can access the data by using dataset property

```js
// in html file
<img
  src="img/logo.png"
  alt="Bankist logo"
  class="nav__logo"
  data-version-number="3.0"
/>;
// also, we need to use camelCase to access the data
console.log(logo.dataset.versionNumber); // 3.0
```

🎨 **Classes**

- classList property is used to add, remove, and toggle classes

```js
logo.classList.add("c", "j");
logo.classList.remove("c", "j");
logo.classList.toggle("c");
logo.classList.contains("c"); // not includes
```

- 🔴 don't use className property to add or remove classes, because it will overwrite all the classes

### 7.4 Smooth Scrolling

```js
const btnScrollTo = document.querySelector(".btn--scroll-to");
const section1 = document.querySelector("#section--1");
btnScrollTo.addEventListener("click", function (e) {
  const s1coords = section1.getBoundingClientRect();
  console.log(e.target.getBoundingClientRect());
  console.log("Current scroll (X/Y)", window.scrollX, window.scrollY);
  console.log(
    "height/width viewport",
    document.documentElement.clientHeight,
    document.documentElement.clientWidth
  );

  // current scroll position + current position of the element
  window.scrollTo(
    left: s1coords.left + window.scrollX,
    top: s1coords.top + window.scrollY,
    behavior: "smooth"
  );

  // 🌟 modern way 🌟
  section1.scrollIntoView({ behavior: "smooth" });
});
```

### 7.5 Types of Events and Event Handlers

> 🤔 Events exist even there's no event handler.

**Event Handlers**

```js
const h1 = document.querySelector("h1");
const alertH1 = function (e) {
  alert("addEventListener: Great! You are reading the heading :D");
};
h1.addEventListener("mouseenter", alertH1);
```

**On-event property**

```js
// we can also use the on-event property to add an event handler
h1.onmouseenter = function (e) {
  alert("addEventListener: Great! You are reading the heading :D");
};
```

-1st Advantage of event handler: on-event property can only have one event handler, but addEventListener() can have multiple event handlers

```js
h1.addEventListener("mouseenter", alertH1);
h1.addEventListener("mouseenter", function (e) {
  alert("addEventListener: Great! You are reading the heading :D");
});
```

- 2nd Advantage of event handler: removeEventListener() method is used to remove an event handler

  ```js
  // remove an event handler within the event handler, so it would only run once
  h1.removeEventListener("mouseenter", alertH1);
  // we can also remove with setTimeout()
  setTimeout(() => h1.removeEventListener("mouseenter", alertH1), 3000);
  ```

  **html attribute**

```html
<!-- we can also add an event handler in the html code -->
<h1 onclick="alert('HTML: Great! You are reading the heading :D')">
  Bankist App
</h1>
```

### 7.6 Event Propagation: Bubbling and Capturing

**3 stages of event propagation**

1. When an event happens on an element, the DOM generates an event object at the root, and **capturing phase** happens, i.e., the event travels all the way down to the target element
2. and then the **target phase** happens, i.e., the event happens on the target element
3. and then the **bubbling phase** happens, i.e., the event travels all the way up to the root element

> 💡 Note that it travels from parent to child, without going through the siblings

- **Event propagation in practice**

  When we click the nav\_\_link element, because of the bubble-up effect, it acts as if the event happens in all the parent elements and triggers the event handlers

```js
const randomInt = (min, max) =>
  Math.floor(Math.random() * (max - min + 1) + min);

const randomColor = () =>
  `rgb(${randomInt(0, 255)},${randomInt(0, 255)},${randomInt(0, 255)})`;
document.querySelector(".nav__link").addEventListener("click", function (e) {
  // e.target is the element that the event happens on, so will be the same for 3 event handlers
  // e.currentTarget is the element that the event handler is attached to
  // this keyword is the same as e.currentTarget
  this.style.backgroundColor = randomColor();
  console.log("LINK", e.target, e.currentTarget);
});
document.querySelector(".nav__links").addEventListener("click", function (e) {
  this.style.backgroundColor = randomColor();
  console.log("CONTAINER", e.target, e.currentTarget);
});
document.querySelector(".nav").addEventListener("click", function (e) {
  this.style.backgroundColor = randomColor();
  console.log("NAV", e.target, e.currentTarget);
});
```

- e.stopPropagation() method is used to stop the event propagation, so the event will not bubble up to the parent elements

- the 3rd parameter of the addEventListener() method is used to specify the phase, and the default value is false, which means the event handler will be called during the bubbling phase, and if we set it to true, the event handler will be called during the capturing phase (from the root)

### 7.7 Event Delegation: Implementing Page Navigation

When we have lots of elements that we want to add event handlers to, we can use event delegation to add event handlers to the **parent element**, and then use the target element to determine which element triggered the event to improve the performance

```js
// 1. Add event listener to the common parent element
// 2. Determine what element originated the event
document.querySelector(".nav__links").addEventListener("click", function (e) {
  e.preventDefault();
  // Matching strategy
  if (e.target.classList.contains("nav__link")) {
    const id = e.target.getAttribute("href");
    document.querySelector(id).scrollIntoView({ behavior: "smooth" });
  }
});
```

### 7.8 DOM Traversing

- Get child elements: el.querySelectorAll(), el.children, el.childNodes, el.firstElementChild, el.lastElementChild

```js
const h1 = document.querySelector("h1");
// returns all child elements of h1 with that className, no matter how deep
console.log(h1.querySelectorAll(".highlight"));
console.log(h1.childNodes); // only direct children, including text and comment
console.log(h1.children); // html collection, live
h1.firstElementChild.style.color = "white";
h1.lastElementChild.style.color = "grey";
```

- Get parent elements: el.parentNode, el.parentElement, el.closest()

```js
// Going upwards: parents
console.log(h1.parentNode);
console.log(h1.parentElement);

// Closest element as specified by the selector, can be parent element or itself
h1.closest(".header").style.background = "var(--gradient-secondary)";

h1.closest("h1").style.background = "var(--gradient-secondary)";
```

- Get sibling elements: el.previousElementSibling, el.nextElementSibling, el.previousSibling, el.nextSibling

```js
// Going sideways: siblings
// Close sibling elements
console.log(h1.previousElementSibling);
console.log(h1.nextElementSibling);
// Close siblings
console.log(h1.previousSibling);
console.log(h1.nextSibling);
// All siblings including itself
console.log(h1.parentElement.children);
[...h1.parentElement.children].forEach((el) => {
  if (el !== h1) el.style.transform = "scale(0.5)";
});
```

### 7.9 Building a Tabbed Component

> The idea to build similar elements: add/remove classes to the elements

Step 1: Add event handler to the parent element
Step 2: Determine what element originated the event with closest() method
Step 3: Remove active classes from all the elements
Step 4: Add active class to the target element

```js
const tabs = document.querySelectorAll(".operations__tab");
const tabsContainer = document.querySelector(".operations__tab-container");
const tabsContent = document.querySelectorAll(".operations__content");

tabsContainer.addEventListener("click", function (e) {
  const clicked = e.target.closest(".operations__tab");
  // Guard clause
  if (!clicked) return;

  // Active tab
  tabs.forEach((t) => {
    t.classList.remove("operations__tab--active");
  });
  clicked.classList.add("operations__tab--active");

  // Active content area
  tabsContent.forEach((c) => {
    c.classList.remove("operations__content--active");
  });
  // select the corresponding content area by template literal
  document
    .querySelector(`.operations__content--${clicked.dataset.tab}`)
    .classList.add("operations__content--active");
});
```

### 7.10 Passing Arguments to Event Handlers

```js
// Menu fade animation
// The handler function can just have one REAL parameter: the event
const changeOpacity = function (e, opacity) {
  // mouseenter doesn't bubble
  if (e.target.classList.contains("nav__link")) {
    const link = e.target;
    const siblings = link.closest(".nav").querySelectorAll(".nav__link");
    const logo = link.closest(".nav").querySelector("img");
    siblings.forEach((el) => {
      if (el !== link) el.style.opacity = this;
    });
    logo.style.opacity = this; // this keyword is pointing to the argument of .bind()
  }
};

// Passing other arguments to an handler with .bind()
nav.addEventListener("mouseover", changeOpacity.bind(0.5));

nav.addEventListener("mouseout", changeOpacity.bind(1));

// or we can use an arrow function
nav.addEventListener("mouseover", (e) => changeOpacity(e, 0.5));
nav.addEventListener("mouseout", (e) => changeOpacity(e, 1));
```

### 7.11 Implementing a Sticky Navigation: The Scroll Event

```js
// Sticky navigation

// scroll event: bad performance
const initialCoords = section1.getBoundingClientRect();
console.log(initialCoords);
window.addEventListener("scroll", function () {
  console.log(window.scrollY);
  if (window.scrollY > initialCoords.top) nav.classList.add("sticky");
  else nav.classList.remove("sticky");
});
```

- We can use the Intersection Observer API to implement the sticky navigation. It's a very useful API which can observe the intersection of an element and the viewport, and it's very useful for lazy loading images, infinite scrolling, and sticky navigation

```js
// Sticky navigation: Intersection Observer API

// get the height of the nav element with getBoundingClientRect() method
const navHeight = nav.getBoundingClientRect().height;

// create a callback function that takes an array of entries as the parameter
const stickyNav = function (entries) {
  // destructure the first element of the array
  const [entry] = entries;
  console.log(entry);
  // use the isIntersecting property to check if the element is intersecting the viewport
  if (!entry.isIntersecting) nav.classList.add("sticky");
  else nav.classList.remove("sticky");
};

const headerObserver = new IntersectionObserver(stickyNav, {
  // the root is the viewport
  root: null,
  // the threshold is the percentage of intersection at which the observer callback will be called
  threshold: 0,
  // we can also specify the root margin, which is the margin around the root
  rootMargin: `-${navHeight}px`,
});
// observe the header element with the observer
headerObserver.observe(header);
```

- Another use case of the Intersection Observer API is to reveal elements on scroll

```js
// reveal sections
const allSections = document.querySelectorAll(".section");
const revealSection = function (entries, observer) {
  const [entry] = entries;
  console.log(entry);

  if (!entry.isIntersecting) return;
  entry.target.classList.remove("section--hidden");
  observer.unobserve(entry.target);
};

const sectionObserver = new IntersectionObserver(revealSection, {
  root: null,
  threshold: 0.15,
});
allSections.forEach((section) => {
  sectionObserver.observe(section);
  section.classList.add("section--hidden");
});
```

- We can improve performance by lazy loading images: use a low resolution image(and blur it) as the src attribute, and use a data-src attribute to store the url of the high resolution image, and then use the Intersection Observer API to load the high resolution image when the low resolution image is intersecting the viewport

```js
// Lazy loading images
const imageTargets = document.querySelectorAll("img[data-src]");

const loadImg = function (entries, observer) {
  const [entry] = entries;
  console.log(entry);
  if (!entry.isIntersecting) return;

  // Replace src with data-src
  entry.target.src = entry.target.dataset.src;
  entry.target.addEventListener("load", function () {
    entry.target.classList.remove("lazy-img");
  });

  observer.unobserve(entry.target);
};
const imageObserver = new IntersectionObserver(loadImg, {
  root: null,
  threshold: 0,
  rootMargin: "500px",
});

imageTargets.forEach(function (image) {
  imageObserver.observe(image);
});
```

### 7.12 Life cycle of DOM Events

- DOMContentLoaded event: fired as soon as the HTML is completely parsed, without waiting for the stylesheets, images, and subframes to load

```js
document.addEventListener("DOMContentLoaded", function (e) {
  console.log("HTML parsed and DOM tree built!", e);
});

// jQuery version
$(document).ready(function () {
  console.log("HTML parsed and DOM tree built!");
});

// load
window.addEventListener("load", function (e) {
  console.log("Page fully loaded", e);
});
// before unload: when we try to close the tab, it will be fired, to make sure that the user doesn't lose any data
window.addEventListener("beforeunload", function (e) {
  e.preventDefault();
  console.log(e);
  e.returnValue = "";
});
```

### 7.13 Efficient Script Loading: defer and async

- When we use regular script tag, the process of browser is: HTML parsing -> script fetching and executing -> HTML parsing -> script execution. To make the browser parse all html first, we put the script tag at the end of the body tag.
- A better way is to use async: we can fetch the script while parsing html, but still the parsing is blocked when executing the script, and
- The best way is to use defer: we can fetch the script while parsing html, and the parsing is not blocked when executing the script. Moreover, defer can garantee the order of the scripts, but async can't.
  > Async and defer only work for head scripts

## 8. Object Oriented Programming with JavaScript

4 fundamental principles of OOP: abstraction, encapsulation, inheritance, and polymorphism

- Abstraction: ignore or hide details that don't matter, so we can focus on the essentials
- Encapsulation: keep some properties and methods private inside the class, so they are not accessible from outside the class. Some methods can be exposed as a public interface (API)
- Inheritance: make all properties and methods of a certain class available to a child class, forming a hierarchical relationship between classes
- Polymorphism: a child class can overwrite a method it inherited from a parent class

### 8.1 OOP in JavaScript

> 💡 In Javascript we don't have 'classes', we have **prototypes**, and we can use prototypes to implement OOP

- Prototypal inheritance: the prototype contains methods (behavior) that are accessible to all objects linked to that prototype (unlike instances copies from classes in classical OOP). AKA **delegation**

  Example: Array.prototype is the prototype of all the arrays, and it contains all the methods that are accessible to all the arrays. We can say our array inherits the methods from Array.prototype, or our array delegates the methods to Array.prototype

- 3 ways to implement prototypal inheritance

  1. Constructor functions: how built-in objects like Arrays, Maps, or Sets are actually implemented, how OOP done in JS before ES6
  2. ES6 classes: a modern alternative to constructor functions, "syntactic sugar", behind the scenes, ES6 classes work exactly like constructor functions, with prototypes and prototypal inheritance
  3. Object.create(): the easiest and most straightforward way of linking an object to a prototype object, but it's not used very often

### 8.2 Constructor Functions and the new Operator

- Constructor function is a convention, instead of attribute of the language itself

```js
// 💡 constructor functions starts with capital letter
// 🟡 Only function expressions/declarations, bc arrow functions don't have 'this' keyword
const Person = function (firstName, birthYear) {
  // Instance properties
  this.firstName = firstName;
  this.birthYear = birthYear;

  // Never do this
  // this.calcAge = function () {
  //   console.log(2037 - this.birthYear);
  // };
};
const jonas = new Person("Jonas,", 1991);
console.log(jonas);
```

🆕 Create instances with function constructor and ES6 class: (but not object.create())

1. New empty object {} is created
2. Function is called, this keyword is set to the new empty object
3. {} empty object linked to the prototype, i.e. the **proto** property
4. function automatically return the new object

```js
// Instances of Person prototype
const matilda = new Person("Matilda", 2017);
console.log(matilda);
console.log(matilda instanceof Person); // true
```

### 8.3 Prototypes

- Each and every function in JS automatically has a property called **prototype**, that includes the constructor. All the objects created through the constructor can get access to all the methods and properties that are defined on the constructor's prototype property
- Only **one copy** of the methods in the prototype, and all the instances can get access to the methods

```js
Person.prototype.calcAge = function () {
  console.log(2037 - this.birthYear);
};
jonas.calcAge(); // 46, because jonas is an instance of Person, and it can get access to the calcAge() method
jonas.__proto__ === Person.prototype; //true, __proto__ is the prototype property of the constructor function. Person.prototype is actually not the prototype of Person, but the prototype of all the instances of Person
console.log(Person.prototype.isPrototypeOf(jonas)); // true
console.log(Person.prototype.isPrototypeOf(Person)); // false

// properties in prototype is not the instance's own property
console.log(jonas.hasOwnProperty("firstName")); // true
console.log(jonas.hasOwnProperty("calcAge")); // false, it's in the prototype
```

### 8.4 Prototypal Inheritance and The Prototype Chain

- If a method is not defined in the object, JS will look for the method in the prototype, making JS performant.

```js
const jonas = new Person("Jonas,", 1991);
jonas.calcAge(); // 46
```

- ⛓️ Prototype chain: ** All objects** in JS has a prototype, and Person.prototype is an object, so it has a prototype, too! which is Object.prototype, and Object.prototype has a prototype, which is null, in other words, Object.prototype is the end of the prototype chain. It works like the scope chain.

```js
// for example, hasOwnProperty() method is defined in Object.prototype, and we can use it in all the objects
console.log(jonas.hasOwnProperty("firstName")); // true
console.log(jonas.__proto__); // Person.prototype, does not include Object methods
console.log(jonas.__proto__.__proto__); // Object.prototype
console.log(jonas.__proto__.__proto__.__proto__); // null
console.dir(Person.prototype.constructor); // Person(firstName, birthYear)
console.log(Person.prototype.constructor); // this will return the code
```

- \***\*proto\*\*** is deprecated, we should use Object.getPrototypeOf() method instead.

### 8.5 Prototypal Inheritance on Built-In Objects

- prototype chain for arrays: Array.prototype -> Object.prototype -> null. All the array functions are defined in Array.prototype, we can use them in all the arrays

```js
const arr = [3, 6, 4, 5, 6, 9, 3]; // new Array === []
console.log(arr.__proto__); // Array.prototype
console.log(arr.__proto__.__proto__); // Object.prototype
console.log(arr.__proto__.__proto__.__proto__); // null
```

- By using the prototype chain, we can add new methods to the built-in objects. But it's not recommended to do so for the built-in objects.

```js
// we can add a new method to the Array.prototype
Array.prototype.unique = function () {
  return [...new Set(this)];
};
console.log(arr.unique()); // [3, 6, 4, 5, 9]
```

- Prototype chain of h1 element: HTMLHeadingElement.prototype -> HTMLElement.prototype -> Element.prototype -> Node.prototype -> EventTarget.prototype -> Object.prototype -> null

### ‼️ 8.6 ES6 Classes

- Classes in JS don't work like classes in other programming languages, but in ES6, we can use the class syntax to implement OOP in JS, behind the scenes, it works exactly like constructor functions and prototypes
- Classes are functions behind the scene, so just like functions, we can use class expressions and class declarations

```js
// Class expression
// const PersonCl = class {}
// Class declaration
class PersonCl {}
```

1. Classes are not hoisted, so we can't use them before they are declared
2. Classes are first-class citizens, we can pass them into functions and return them from functions
3. Classes are executed in strict mode

- ES6 classes are good in formatting the code though.

### 8.7 Setters and Getters

Getter and setters in Javascript are properties, instead of methods. So instead of call them, we can get and set them like properties.

- Getter and setter in regular object

```js
const account = {
  owner: "Jonas",
  movements: [200, 530, 120, 300],

  get latest() {
    return this.movements.slice(-1)[0]; // or this.movements.slice(-1).pop();
  },

  set latest(mov) {
    this.movements.push(mov);
  },
};

console.log(account.latest); // 300
account.latest = 50; // equals to pass 50 to the setter
console.log(account.movements); // [200, 530, 120, 300, 50]
```

- Getter and setter in class

````js
class Personcl {
  constructor(firstName, birthYear) {
    this.firstName = firstName;
    this.birthYear = birthYear;
  }

  // Methods will be added to teh .prototype property
  calcAge() {
    console.log(2037 - this.birthYear);
  }

  greet() {
    console.log(`Hey ${this.firstName}`);
  }

  get age() {
    return 2037 - this.birthYear;
  }
}

const jessica = new Personcl("jessica", 1996);
console.log(jessica);
jessica.calcAge(); // 41
console.log(jessica.age); // 41, we use that without parentheses, because it's a getter

// It's a bit tricky to user getter and setter in classes. For data validation, we need to first set the value to a new property in our setter, and then use that property in our getter
```js
class Personcl {
  constructor(fullName, birthYear) {
    this.fullName = fullName;
    this.birthYear = birthYear;
  }

  set fullName(name) {
    if (name.includes(' ')) this._fullName = name;
    else alert(`${name} is not a full Name`);
  }
  get fullName() {
    return this._fullName;
  }
}
````

### 8.8 Static Methods

Static methods are attached to the very **constructor** function, and not to the prototype. So we can't use static methods on the instances, but only on the constructor function itself.

```js
// Array.from() is a static method, all the arrays don't inherit this method
Array.from(document.querySelectorAll("h1")); // correct usage
document.querySelectorAll("h1").from(); // wrong usage
// The same for Number.parseFloat()
Number.parseFloat("2.5rem"); // correct usage

// To define a static method, we simply use Constructor.functionName
Person.hey = function () {
  // if non-static, should be declared as Person.prototype.hey = function () {}
  console.log("Hey there 👋");
  console.log(this);
};

// Or we can define a static method in the class by simply add a static keyword
class Person {
  static hey() {
    console.log("Hey there 👋");
    console.log(this); // static method has its own this keyword, which is the constructor function
  }
}
```

### 8.9 Object.create()

To create new object this way, we first need to create a prototype object with object literal, and then pass it to the Object.create() method, and then we can create new objects based on that prototype object. This is not used very often.

```js
const PersonProto = {
  calcAge() {
    console.log(2037 - this.birthYear);
  },
};

const steven = Object.create(PersonProto);
steven.name = "Steven";
steven.birthYear = 2002;
steven.calcAge(); // 35
```

> 💡 _What's going on here?_
> Object.create() method creates a new object, and sets the prototype of that object to whatever we pass into the method. So the prototype of steven is PersonProto, and the prototype of PersonProto is Object.prototype

### 8.10 Inheritance Between "Classes": Constructor Functions

- "Real inheritance" in JS: apart from prototypal inheritance, child class can inherit the methods from parent class, and we can also add new methods to the child class.

```js
const Person = function (firstName, birthYear) {
  this.firstName = firstName;
  this.birthYear = birthYear;
};

Person.prototype.calcAge = function () {
  console.log(2037 - this.birthYear);
};

const Student = function (firstName, birthYear, course) {
  Person.call(this, firstName, birthYear); // we need to bind the this keyword to the Student object by using call() method
  this.course = course;
};
const mike = new Student("Mike", 2020, "Computer Science");
```

- We wanna manually create a prototype chain, i.e., to let Student.prototype's **proto** property pointing to Person.prototype. We need to use Object.create() method to do so.

```js
Student.prototype = Object.create(Person.prototype); // Student.prototype.__proto__ = Person.prototype
// A = Object.create(B), A inherits from B. So we can say Student.prototype inherits from Person.prototype

// the wrong way
// Student.prototype = Person.prototype; // in this way, student and person would be at the same level
```

- When we call mike.calcAge(), the JS engine will first look for the method in mike, and then in Student.prototype, and then in Person.prototype, all the way up. That's why polymorphism works: when we overwrite a method in the child class, the method in teh child class will be used.

### 8.11 Inheritance Between "Classes": ES6 Classes

- Behind the scenes, ES6 classes work exactly like constructor functions and prototypes, so we can use the same way to implement inheritance between classes

```js
class Person {
  constructor(firstName, birthYear) {
    this.firstName = firstName;
    this.birthYear = birthYear;
  }
  calcAge() {
    console.log(2037 - this.birthYear);
  }
}

// to interit, we need the extends keyword and super() method

// if we don't have any new properties in the child class, we don't need to create a new constructor function
class Student extends Person {
  constructor(firstName, birthYear, course) {
    // this need to happen first, because we will be able to use the this keyword after calling super()
    super(firstName, birthYear); // super() method is used to call the parent constructor function, and we need to pass in the parameters
    this.course = course;
  }
  introduce() {
    console.log(`My name is ${this.firstName} and I study ${this.course}`);
  }
  // we can also overwrite the parent method
  calcAge() {
    console.log(
      `I'm ${
        2037 - this.birthYear
      } years old, but as a student, I feel more like ${
        2037 - this.birthYear + 10
      }`
    );
  }
}

const martha = new Student("Martha", 2012, "Computer Science");
martha.introduce(); // My name is Martha and I study Computer Science
martha.calcAge(); // 25
```

### 8.12 Inheritance Between "Classes": Object.create()

1. Create a prototype object with object literal
2. Create a new prototype object with Object.create()
3. Create new objects based on the new prototype, which is the child of our original prototype

```js
const PersonProto = {
  calcAge() {
    console.log(2037 - this.birthYear);
  },
  init(firstName, birthYear) {
    this.firstName = firstName;
    this.birthYear = birthYear;
  },
};

const StudentProto = Object.create(PersonProto);
const jay = Object.create(StudentProto);

StudentProto.init = function (firstName, birthYear, course) {
  PersonProto.init.call(this, firstName, birthYear);
  this.course = course;
};
StudentProto.introduce = function () {
  console.log(`My name is ${this.firstName} and I study ${this.course}`);
};

jay.init("Jay", 2010, "Computer Science");
jay.introduce(); // My name is Jay and I study Computer Science
jay.calcAge(); // 27, inheritance works
```

### 8.13 Encapsulation: Protected Properties and Methods

Reasons to use encapsulation:

1. To protect the data, i.e., to prevent code from outside to accidentally manipulate the data
2. We can be more confident when we change the internal implementation of the class, because we know that the public API will not be affected

We can protect the properties and methods by using \_ in front of the name, but it's not a real protection, it's just a convention.

```js
class Account {
  constructor(owner, currency, pin) {
    this.owner = owner;
    this.currency = currency;
    this._pin = pin; // protected property
    this._movements = [];
    this.locale = navigator.language;
    console.log(`Thanks for opening an account, ${owner}`);
  }
}
```

💡 Truly private class fields are a stage 3 proposal for a new version of JS, and they are not supported by all the browsers yet.

```js
class Account {
  // 1. Public fields (instances)
  locale = navigator.language;
  // 2. Private fields (instances, but not the prototype)
  #movements = [];
  #pin;

  // 3. Public fields (prototype)

  // public interface
  constructor(owner, currency, pin) {
    this.owner = owner;
    this.currency = currency;
    this.#pin = pin;
    console.log(`Thanks for opening an account, ${owner}`);
  }

  // 4. Private methods: not supported by all the browsers yet
  #approveLoan(value) {
    return true;
  }
}

const acc1 = new Account("Jonas", "EUR", 1111);
console.log(acc1);
console.log(acc1.#movements); // Uncaught SyntaxError: Private field '#movements' must be declared in an enclosing class
```

### 8.14 Chaining Methods

```js
acc1.deposit(300).deposit(500).withdraw(35).requestLoan(25000).withdraw(4000); // the methods return the current object, so we can chain the methods
```

### 8.15 ES6 Classes Summary

1. We define a class by the class keyword
2. We define properties in the constructor method
3. Public and private fields are defined in the class body, but not in the constructor method. Static fields are defined in the class body, too. Fields are common to all the instances, and they are not on the prototype, but we can redefine them in the instances
4. Constructor method is called by the new operator
5. When we call a method on an object, the method is first looked up in the object itself, and then in the prototype of the object, and then in the prototype of the prototype, all the way up the prototype chain
6. Getter and setter: we can use them like properties, but they are actually methods with get and set keywords， if we have a setter for a variable already in the constructor, we need to use a different variable name with \_ in front of it
7. static method: only available on the constructor function, not on the instances, and not in **proto**

## 9. Asynchronous JavaScript: Promises, Async/Await and AJAX

Sync vs Async
Sync: code is executed line by line, and each line of code waits for the previous line to finish
Async: code is executed without blocking or waiting for the previous line to finish

- setTimeout() is an async function, it will be executed after 3 seconds, and the code after it will be executed first. ❕callback function is not necessarily async, it depends on the function itself

```js
const p = document.querySelector("p");
setTimeout(() => {
  console.log("1 second passed");
  p.textContent = "1 second passed";
}, 1000);
p.style.color = "red"; // this is not blocked by the timer, because timer is async
```

- event listener for load: the callback function will be executed after the page is loaded, and the code after it will be executed first (not all event handler are async)

```js
window.addEventListener("load", function () {
  console.log("Page loaded");
});
```

### 9.1 AJAX: Asynchronous JavaScript and XML

- With AJAX, we can send HTTP requests to the server from JavaScript, and we can receive data from the server, and then use the data to dynamically change the page without reloading the page. It works async.
- We're not actually using XML, but JSON, which is a subset of JavaScript, and it's a very popular data format for sending data between a client and a server

```js
// https://countries-api-836d.onrender.com/countries/
const getCountryData = function (country) {
  const btn = document.querySelector(".btn-country");
  const countriesContainer = document.querySelector(".countries");

  ///////////////////////////////////////
  // Old way of doing AJAX
  const request = new XMLHttpRequest();
  request.open("GET", `https://restcountries.com/v2/name/${country}`);
  request.send();

  request.addEventListener("load", function () {
    const [data] = JSON.parse(this.responseText); // json is a string, so we need to parse it with JSON.parse(). The result is an array of objects, so we use destructuring to get the first element
    console.log(data); // the object

    const html = `<article class="country">
  <img class="country__img" src="${data.flag}" />
  <div class="country__data">
    <h3 class="country__name">${data.name}</h3>
    <h4 class="country__region">${data.region}</h4>
    <p class="country__row"><span>👫</span>${(
      +data.population / 1_000_000
    ).toFixed(1)} million people </p>
    <p class="country__row"><span>🗣️</span>${data.languages[0].name}</p>
    <p class="country__row"><span>💰</span>${data.currencies[0].name}</p>
  </div>
</article>`;
    countriesContainer.insertAdjacentHTML("beforeend", html);
    countriesContainer.style.opacity = 1;
  });
};
// The order of the countries is not guaranteed, because the requests are asynchronous, whichever request finishes first will trigger the event listener first.
getCountryData("portugal");
getCountryData("canada");
getCountryData("usa");
```

### 9.2 How the Web Works Behind the Scene: Request and Response

Client -> Request -> Server
Client <- Response <- Server

1. Browser makes a request to a DNS, which would convert the domain name to an IP address (with IP address and port number, the browser can find the server)
2. TCP/IP(the internet fundamental protocols) connection is established between the client and the server
3. HTTP request is sent to the server
   ```js
   // the request. We can not only send GET request, but also POST, PUT, DELETE, etc.
   GET /rest/v2/name/portugal HTTP/1.1
   // the request header
    Host: restcountries.com
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:89.0) Gecko/20100101 Firefox/89.0
    Accept-Language: en-US,en;q=0.5
    <BODY> // only when we send POST request
   ```
   HTTPS is a secure version of HTTP, and it uses SSL/TLS certificates to encrypt the data
4. HTTP response is sent from the web server to the client

   ```js
   // the response
   HTTP/1.1 200 OK
   // the response header
   Date: Tue, 15 Jun 2021 03:30:00 GMT
   Content-Type: application/json; charset=utf-8
   Content-Length: 1234
   <BODY> // the response body

   ```

5. Browser renders the HTML, CSS, and JavaScript. The request process is repeated for every resource on the page

### 9.3 Make AJAX calls

```js
const getCountryData = function (country) {
  const btn = document.querySelector(".btn-country");
  const countriesContainer = document.querySelector(".countries");

  ///////////////////////////////////////
  // Old way of doing AJAX
  const request = new XMLHttpRequest();
  request.open("GET", `https://restcountries.com/v2/name/${country}`);
  request.send();

  // Event handlers for AJAX calls: when the state of the request changes, the event handler will be called
  request.addEventListener("load", function () {
    const [data] = JSON.parse(this.responseText); // json is a string, so we need to parse it with JSON.parse(). The result is an array of objects, so we use destructuring to get the first element
    console.log(data); // the object

    const html = `<article class="country">
  <img class="country__img" src="${data.flag}" />
  <div class="country__data">
    <h3 class="country__name">${data.name}</h3>
    <h4 class="country__region">${data.region}</h4>
    <p class="country__row"><span>👫</span>${(
      +data.population / 1_000_000
    ).toFixed(1)} million people </p>
    <p class="country__row"><span>🗣️</span>${data.languages[0].name}</p>
    <p class="country__row"><span>💰</span>${data.currencies[0].name}</p>
  </div>
</article>`;
    countriesContainer.insertAdjacentHTML("beforeend", html);
    countriesContainer.style.opacity = 1;
  });
};
// The order of the countries is not guaranteed, because the requests are asynchronous, whichever request finishes first will trigger the event listener first.
getCountryData("portugal");
getCountryData("canada");
getCountryData("usa");
```

### 9.4 Callback Hell

- To specify the sequence of async functions execution, we can use nested callbacks, i.e., have a second callback inside the first callback, so the second callback would only be executed after the first request is finished.
- But if there are more requests, the code would be very messy, creating a "callback hell". So we can use promises to solve this problem.

### 9.5 Promises and the Fetch API

Since ES6, we can use promises to solve the callback hell problem. A promise is an object that is used as a placeholder for the future result of an async operation. A promise is a container for an asynchronously delivered value.

```js
// The modern way of making an AJAX call: with the fetch API
const request = fetch("https://restcountries.com/v2/name/portugal");
console.log(request); // returns a promise stored in the request variable
```

With promises, we can chain, instead of nest the operations.

Promise lifecycle:
pending -> settled/fulfilled or rejected
We are able to consume the promise only after it's settled.

- Create promise -> consume promise
  Most of the time, we don't create promises ourselves, but we consume promises created by the browser APIs, like fetch(). We also need to create promises sometimes

### 9.6 Consuming Promises && Chaining Promises

```js
const getCountryData = function (country) {
  fetch(`https://restcountries.com/v2/name/${country}`)
    .then((response) => response.json()) // available in the fetch API for all response objects, also an async function
    .then((data) => renderCountry(data[0])); // resolved value of json()
};

getCountryData("portugal");
```

- Handle the neighboring countries

```js
const getCountryData = function (country) {
  fetch(`https://restcountries.com/v2/name/${country}`)
    .then((response) => {
      if (!response.ok)
        throw new Error(`Country not found (${response.status})`); // throw an error to reject the promise, jump to catch()
      return response.json();
    }) // json() is also available in the fetch API for all response objects, also an async function
    .then((data) => {
      renderCountry(data[0]);
      const neighbour = "alala";
      if (!neighbour) return;
      // Country 2
      fetch(`https://restcountries.com/v2/alpha/${neighbour}`)
        // What we got returned from the last promise will be the input for the next promise
        .then((response) => response.json())
        .then((data) => renderCountry(data, "neighbour"))
        .catch(error)=>console.error(`${error}💥💥`);
    }) // resolved value of json()
};

getCountryData("germany");
```

- Don't nest promises: always return them and chain them outside. That's the point of using promises rather than callbacks.

### 9.7 Handling Rejected Promises

There are 2 ways to handle rejected promises:

1. use the second callback function in then() method
2. use catch() method at the end of the promise chain, all the promises in the chain will be handled by the catch() method

```js
promise.catch((err) => {
  // catch also returns a paomise
  console.error(`${err}💥💥`);
  renderError(`Something went wrong ${err.message}`);
});
```

- The finally() method will be called no matter the promise is fulfilled or rejected

```js
// this can be chained after catch(), because catch() also returns a promise
promise.finally(() => {
  countriesContainer.style.opacity = 1;
});
```

- Reject a promise manually: we can immediately reject a promise by throwing an error. It's important to anticipate all the possible errors, and reject the promise manually to handle them.

```js
// we need to catch error to display the error message
const getCountryData = function (country) {
  return fetch(`https://restcountries.com/v2/name/${country}`)
    .then(
      response => {
        if (!response) throw new Error('Country not found!');
        return response.json();
      }
}
```

### 9.8 Using muliple APIs together

```js
const whereAmI = (lat, long) => {
  return fetch(
    `https://geocode.xyz/${lat},${long}?geoit=json&auth=876832653189406248097x49051`
  )
    .then((response) => {
      if (!response) throw new Error("No location found!");
      if (response.status == "403") throw new Error("Too many requests!");
      return response.json();
    })
    .then((data) => {
      if (!data.country) throw new Error("No country found!");
      console.log(`You are in ${data.city}, ${data.country}`);
      return fetch(`https://restcountries.com/v2/name/${data.country}`);
    })
    .then((res) => {
      if (!res.ok) throw new Error("country not found!");
      return res.json();
    })
    .then((data) => renderCountry(data[0]))
    .catch((error) => {
      console.log(error);
    });
};

whereAmI(-33.933, 18.474);
whereAmI(52.508, 13.381);
whereAmI(19.037, 72.873);
```

### 9.9 Asynchronous Behind the Scenes: The Event Loop

Review: Javascript runtime
![Alt text](https://i.imgur.com/sn6oAWK.jpg)

- the engine: where the code is executed and objects are stores (in call stack and heap)
- Javascript only has **1** thread of execution, which means it can only do 1 thing at a time
- web API (DOM, AJAX, Timeout, etc.) is not part of the JS engine, it's provided to teh engine
- Callback queue: where the callback functions are stored. When call stack is empty, the callback functions will be moved to the call stack by the event loop, and then executed

> 🤔❓ If we only have one thread of execution, how can we handle asynchronous tasks in a non-blocking way?

- The async tasks are executed in the WEB API environment firstly, and then a callback is registered in the call stack. When the event is fullfilled, the callback will be moved to the callback queue, which is a to-do list for the event loop. When the call stack is empty, the event loop will move the callback to the call stack, and execute it.

- Example: if there's another task in the queue that takes 1 second to finish, the timer will be delayed for 1 second, and the callback will be moved to the call stack after 1 second.

The process:

1. setTimeout() is called, and the callback function is registered in the WEB API environment
2. the counting down is finished, and the callback function is moved to the callback queue
3. The callback function is the first in the callback queue
4. The call stack is empty, and the event loop moves the callback function to the call stack, and execute it

The engine doesn't have concept of time, all the async tasks are handled by the WEB API environment, and the event loop.

For promises, the callback function is registered in the microtask queue, which has a higher priority than the callback queue. So the callback function in the microtask queue will be executed first.

```js
console.log("Test start");
setTimeout(() => console.log("0 sec timer"), 0);
Promise.resolve("Resolved promise 1").then((res) => console.log(res));
Promise.resolve("Resolved promise 2").then((res) => {
  for (let i = 0; i < 1000000000; i++) {}
  console.log(res);
});
// the execution order is: Test start -> Resolved promise 1 -> Resolved promise 2 -> 0 sec timer
```

### 9.10 Building a Simple Promise

- Promises are special objects, so we create it with the new keyword, and pass an executor function into it as the argument.
- As soon as the creator function is called, the executor function will be executed automatically, and it will immediately start the async work.

```js
const lotteryPromise = new Promise(function (resolve, reject) {
  // creating an instance of the Promise class
  // executor function
  if (Math.random() >= 0.5) {
    resolve("You win!"); // fulfilled, the value will be passed to the then() method
  } else {
    reject(new Error("You lost your money!")); // rejected, the value will be passed to the catch() method
  }
});
```

- Consume the promise

```js
lotteryPromise
  .then((res) => console.log(res))
  .catch((err) => console.error(err));
```

- Then we can begin to make it async

```js
const lotteryPromise = new Promise(function (resolve, reject) {
  // creating an instance of the Promise class
  // executor function
  console.log("Lottery draw is happening 🔮");
  setTimeout(function () {
    if (Math.random() >= 0.5) {
      resolve("You win!"); // fulfilled, the value will be passed to the then() method
    } else {
      reject(new Error("You lost your money!")); // rejected, the value will be passed to the catch() method
    }
  }, 2000);
});
```

- We can also promisify the callback functions to avoid callback hell

```js
const wait = function (seconds) {
  return new Promise(function (resolve) {
    setTimeout(resolve, seconds * 1000);
  });
};

wait(1)
  .then(() => {
    console.log("I waited for 1 second");
    return wait(1);
  })
  .then(() => {
    console.log("I waited for 2 seconds");
    return wait(1);
  })
  .then(() => {
    console.log("I waited for 3 seconds");
    return wait(1);
  })
  .then(() => console.log("I waited for 4 seconds"));
```

### 9.11 Promisifying API

```js
// navigator.geolocation.getCurrentPosition() is a callback function, we can promisify it
const getPosition = function () {
  return new Promise(function (resolve, reject) {
    // by this, we pass the response of the callback function to the resolve() function, and the error to the reject() function of our promise
    navigator.geolocation.getCurrentPosition(resolve, reject);
  });
};

getPosition().then((pos) => console.log(pos));
```

### 9.12 Promisifying the setTimeout() Function

```js
// simply return a new promise after several seconds than we can chain it
const wait = function (seconds) {
  return new Promise(function (resolve) {
    setTimeout(resolve, seconds * 1000);
  });
};

// the new Promise constructor defines the value of the promise
function createImage(imgPath) {
  return new Promise((resolve, reject) => {
    const newImg = document.createElement("img");
    newImg.src = imgPath;
    newImg.addEventListener("load", () => {
      document
        .querySelector(".images")
        .insertAdjacentElement("afterbegin", newImg);
      resolve(newImg);
    });

    newImg.addEventListener("error", () => {
      reject(new Error("Image not found"));
    });
  });
}
let currentImg;
createImage("img/img-1.jpg")
  .then((img) => {
    currentImg = img;
    console.log("Image 1 loaded");
    return wait(2);
  })
  .then(() => {
    currentImg.style.display = "none";
    return createImage("img/img-2.jpg");
  })
  .then((img) => {
    currentImg = img;
    console.log("image 2 loaded");
    return wait(2);
  })
  .then(() => {
    currentImg.style.display = "none";
    return createImage("img/img-3.jpg");
  })
  .then((img) => {
    currentImg = img;
    console.log("image 3 loaded");
  })
  .catch((err) => console.error(err));
```

### 9.13 Consuming Promises with Async/Await

From ES6, we can use async/await to consume promises.

- By adding async keyword in front of a function, we can make the function return a promise, and the value of the promise will be the return value of the function.
- await() will stop the code execution until the promise is fulfilled, but it's not blocking the main thread, so the code after await() will be executed first.

```js
const whereAmI = async function () {
  // location
  const pos = await getPosition();
  const { latitude: lat, longitude: lng } = pos.coords;
  // reverse geoCoding
  const response = await fetch(
    `https://geocode.xyz/${lat},${lng}?geoit=json&auth=876832653189406248097x49051`
  );
  const position = await response.json();
  const country = position.country;
  // country data
  const res = await fetch(`https://restcountries.com/v2/name/${country}`);
  const data = await res.json();
  renderCountry(data[0]);
};
whereAmI();
console.log("FIRST");
```

### 9.14 Error Handling with try...catch

```js
const whereAmI = async function () {
  try {
    // location
    const pos = await getPosition();
    const { latitude: lat, longitude: lng } = pos.coords;
    // reverse geoCoding
    const response = await fetch(
      `https://geocode.xyz/${lat},${lng}?geoit=json&auth=876832653189406248097x49051`
    );
    const position = await response.json();
    const country = position.country;
    // country data
    const res = await fetch(`https://restcountries.com/v2/name/${country}`);
    const data = await res.json();
    renderCountry(data[0]);
    return `You are in ${country}`;
  } catch (err) {
    console.error(err);
    renderError(`Something went wrong ${err.message}`);
  }
};
```

### 9.15 Returning Values from Async Functions

Async functions always return a promise, so we can use then() method to consume the promise.
But if there's an error in the async function, we cannot reach the return statement, but the promise will still be fulfilled, and the value of the promise will be undefined.

```js
whereAmI()
  .then((res) => console.log(res))
  .catch((err) => console.error(err));
```

- So we need to throw an error again in the catch() method, and then we can catch the error in the next catch() method

```js
...
  } catch (err) {
    console.error(err);
    renderError(`Something went wrong ${err.message}`);
    throw err;
  }
...
```

- In ES6, we cannot use await() in the top level code, so we need to wrap the code in an IIFE

```js
(async function () {
  try {
    const city = await whereAmI();
    console.log(city);
  } catch (err) {
    console.error(err);
  }
})();
```

### 9.16 Running Promises in Parallel

- Instead of using await() one another, we can use the combinator Promise.all() to run promises in parallel, and the result will be an array of the results of all the promises.
- Promise.all accepts an array of requests, and returns an array of fulfilled promises. If one of the promises is rejected, the whole Promise.all() will be rejected.

```js
const data = await Promise.all([
  fetch(`https://restcountries.com/v2/name/${country1}`),
  fetch(`https://restcountries.com/v2/name/${country2}`),
  fetch(`https://restcountries.com/v2/name/${country3}`),
]);
```

### 9.17 Other combinators: Promise.race(), Promise.allSettled(), Promise.any()

- in Promise.race(), no matter the promise is fulfilled or rejected, the result will be the first promise that is settled

```js
(async function () {
  const res = await Promise.race([
    getJSON(`https://restcountries.com/v2/name/italy`),
    getJSON(`https://restcountries.com/v2/name/japan`),
    getJSON(`https://restcountries.com/v2/name/taiwan`),
  ]);
  console.log(res[0]);
})();
```

- We can use Promise.race() with a timer to prevent the promise from taking too long to settle

```js
const timeout = function (s) {
  return new Promise(function (_, reject) {
    setTimeout(function () {
      reject(new Error("Request took too long!"));
    }, s * 1000);
  });
};

Promise.race([getJSON(`https://restcountries.com/v2/name/italy`), timeout(3)])
  .then((res) => console.log(res[0]))
  .catch((err) => {
    console.log(err);
  });
```

- A new method in ES2020: Promise.allSettled() returns an array of all the settled promises, no matter they are fulfilled or rejected

```js
Promise.allSettled([
  Promise.resolve("success"),
  Promise.reject("ERROR"),
  Promise.resolve("success"),
])
  .then((res) => console.log(res))
  .catch((err) => console.error(err));
// the result is an array of objects, each object has a status property, which is either fulfilled or rejected
```

- Promise.any() returns the first fulfilled promise, and ignores the rejected promises

```js

```

## 10. Modern JavaScript Development: Modules, Tools and Setup

♻️ Modules=>bundling=>transpiling=>javascript bundle in production
🔧 Tools: npm, parcel, webpack, babel

### 10.1 Modules in JavaScript

- A module is usually a standalone file, is a reusable piece of code that encapsulates implementation details.
- In a module, we can import contents from other modules, and export contents to other modules. The imported modules are called dependencies, coz they are depended on by the current module.
- Compose software: we can put the modules together to build complex applications

|                     | ES6 Modules              | Regular Script |
| ------------------- | ------------------------ | -------------- |
| Top-level variables | Scope to the module      | Global scope   |
| Default mode        | Strict mode              | Sloppy mode    |
| Top-level this      | undefined                | window         |
| Imports and exports | Yes                      | No             |
| HTML Linking        | `<script type="module">` | `<script>`     |
| File downloading    | Asynchronous             | Synchronous    |

#### Importing ES6 Modules

- Imports are hoisted, so we can import the modules at the top of the file, and use them later.

  > 💡 review of the concept of hoisting: the variables and functions are hoisted to the top of the scope before execution, so we can use them before they are declared. The import statements are also hoisted, so even when we put them in the end, they will be executed first, before the current module

- When the current module is parsed (read but not executed), the imports will be resolved, and the dependencies will be downloaded (asynchronously). Then the current module will be executed.
- The import is a **live connection** to the exported value, so if the exported value changes, the imported value will change, too. It's a reference in memory, not a copy.

```js
import "./shoppingCart.js";
console.log("Importing module");

// in shoppingCart.js
console.log("Exporting module");

// the result is:
// Exporting module
// Importing module
// All the codes in the imported module will be executed first, and then the codes in the current module will be executed
```

#### Export: named exports and default exports

🟡 Beware export can only happen in top-level code, not inside a block, or a function

Name exports:

- we can export multiple values from a module, and we can import them with the same name, or with a different name, but we need to use the same name in the curly braces
- We can change the name of the exported value with the as keyword

```js
// export
export const addToCart = function (product, quantity) {
  cart.push({ product, quantity });
  console.log(`${quantity} ${product} added to cart`);
};
// import
import { addToCart } from "./shoppingCart.js";
// or use the as keyword
import { addToCart as add, totalPrice, tq } from "./shoppingCart.js";
```

- We can also import all the exported values as an object, and use the object to access the exported values. We we use the variables, we need to use the object name in front of them.

```js
import * as ShoppingCart from "./shoppingCart.js";
ShoppingCart.addToCart("bread", 5);
```

- Default exports: we can only have one default export in a module, and we can import it with any name we want, without the curly braces

```js
// export
export default function (product, quantity) {
  cart.push({ product, quantity });
  console.log(`${quantity} ${product} added to cart`);
}
// import
import add from "./shoppingCart.js";
```

### 10.2 Top-level await

Starting from ES2022, we can use await() in the top-level code in a module, without an async function. But we need to add the type="module" attribute in the script tag.

```js
const res = await fetch("https://restcountries.com/v2/name/portugal");
const data = await res.json();
console.log(data);
```

👎 this can be problematic, because it might block the whole page from loading.

👍 Let's see a more real-world example, where top-level await is useful (for return values of async functions)

```js
const getLastPost = async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts");
  const data = await res.json();
  return { title: data.at(-1).title, body: data.at(-1).body };
};
// This is not gonna work, coz async functions return promises instead of values
const lastPost = getLastPost();
console.log(lastPost);
// we can use then() method to consume the promise, but this is not very clean
// getLastPost().then((res) => console.log(res));

// So we can use top-level await
const lastPost = await getLastPost();
```

🔺 The top-level await in imported module would not only block the execution of the imported module, but also the execution of the current module.

### 10.3 The Module Pattern before ES6 Modules

- Modules are a great way to encapsulate code, but they are not the only way to do it. We can use the module pattern to encapsulate code in an object, and expose only the public interface to the outside.
- We can wrap it in an IIFE, and return an object with the public methods. The private methods are not accessible from the outside.

```js
const = ShoppingCart = (function () {
  const cart = [];
  const shippingCost = 10;
  const totalPrice = 237;
  const totalQuantity = 23;
  const addToCart = function (product, quantity) {
    cart.push({ product, quantity });
    console.log(`${quantity} ${product} added to cart`);
  };
  const orderStock = function (product, quantity) {
    console.log(`${quantity} ${product} ordered from supplier`);
  };
  return {
    addToCart,
    cart,
    totalPrice,
    totalQuantity,
  };
})();

// so we can access the public methods and properties
ShoppingCart.addToCart("apple", 4);

// but we cannot access the private methods and properties
ShoppingCart.shippingCost; // undefined
```

- We can use the public methods to manipulate the private properties even after the IIFE is executed, because the closures are still there: the public methods still have access to the variables in its birthplace.

### 10.4 CommonJS Modules

For node.js apps, we can use CommonJS modules, which are synchronous, and they are not available in the browser. We can use the require() function to import modules, and the module.exports to export modules.

```js
// export: with the dot notation
export.addToCart = function (product, quantity) {
  cart.push({ product, quantity });
  console.log(`${quantity} ${product} added to cart`);
};
// import: with the require() function
const { addToCart } = require("./shoppingCart.js");
```

### 10.5 A Brief Introduction to command line

Some common commands:

```bash
## we are always in a folder, to check the content of the folder:
ls
## to go to a folder:
cd folderName
## to go back to the parent folder:
cd ..
## to go back to the root folder:
cd ~
## to create a new folder under the current folder:
mkdir folderName
## to delete a folder:
rm -R folderName
## to delete an empty folder:
rmdir folderName
## to clear the terminal:
clear
## auto complete the file name: hit tab
## to create a new file:
touch fileName
## to delete a file:
rm fileName
## to move a file:
mv fileName folderName

## to open a file in live server:
live-server
## Arrow up to see the previous command
```

### 10.6 Introduction to NPM

- Before we have npm, we just link external scripts in the html file, and use the global variables in the scripts.
- We can use npm without node.js, but we need node.js to run the scripts.
- Without bundler, we need to use ES6 syntax to import and export modules.

```js
// for example, we can use the lodash library to manipulate arrays and objects
import cloneDeep from "../node_modules/lodash-es/cloneDeep.js";

const state = {
  cart: [
    { product: "bread", quantity: 5 },
    { product: "pizza", quantity: 5 },
  ],
  user: { loggedIn: true },
};
// deep clone: clone all the nested objects without sharing the same reference
const stateClone = Object.assign({}, state);
const stateDeepClone = cloneDeep(state);
state.user.loggedIn = false;
console.log(stateClone); // the user.loggedIn property is also changed, because the user object is not cloned, but shared the same reference
console.log(stateDeepClone); // the user.loggedIn property is not changed, because the user object is cloned
```

### 10.7 Bundling with Parcel and NPM Scripts

to bundle our modules together..

- install parcel as a dev dependency

```bash
npm i parcel --save-dev
```

- run parcel in the terminal

```bash
## as parcel is not installed globally, we can run it with npx
## index.html is our entry point, where we include our script
npx parcel index.html
```

### 10.7 Review: Writing Clean and Modern JavaScript

**General:**

- Write readable code: use descriptive variable names, use comments, use meaningful indentation, etc.
- DRY principle: Don't Repeat Yourself
- Don't use var, use const and let instead
- Use strong type checking: use === and !== instead of == and !=

**Functions:**

- Each function should have only one task
- Don't use more than 3 function parameters
- Use arrow functions when they make the code more readable (callback functions, one-liner functions, etc.)

**OOP:**

- Use ES6 classes
- Encapsulate code in modules
- Implement method chaining
- DON'T use arrow functions as methods in objects, because the this keyword will point to the global object, not the object itself

**Avoid nesting:**

- Use guard clauses instead of if-else for early return
- Use ternary operator instead of if-else for simple conditions
- Use multiple if statements instead of if-else for multiple conditions
- Avoid for loops, use forEach(), map(), filter(), reduce(), find(), etc. instead
- Avoid callback-based asynchronous APIs

**Asynchronous:**

- Consume promises with async/await for better readability
- Whenever possible, run promises in parallel, instead of chaining them (Promise.all())
- Handle errors and promise rejections, by using try...catch block

### 10.8 Declarative and Functional JavaScript

Imperative vs Declarative programming

- Imperative: how to do things
- Declarative: what to do

Declerative is more and more popular in modern javascript, because it's more readable, and easier to maintain.

```js
// Imperative
const arr = [1, 2, 3];
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
// Declarative
const arr = [1, 2, 3];
arr.forEach((num) => console.log(num));
// or
const arr = [1, 2, 3];
arr.map((num) => num * 2);
```

📖 Functional programming

- Declarative programming paradigm
- Based on the idea of writing software by combining many pure functions, avoiding side effects and mutating data

  🔴 Side effects: Modification of any data outside of the function (mutating external variables, logging to console, writing to DOM, etc.)

  🟢 Pure function: A function without side effects, and always returns the same result given the same input

  🟢 Immutability: State (data) is never modified! Instead, state is copied, and the copy is mutated and returned. Example: in Redux, we never mutate the state, but return a new state.

#### Functional programming techniques

- Try avoid data mutations
  ```js
  Object.freeze(); // make an object immutable
  // it's not a deep freeze, so we need to freeze all the nested objects
  ```
- Use built-in methods that don't produce side effects
- Do data transformations with methods like map(), filter(), reduce()
- Try to avoid for loops, use forEach(), map(), filter(), reduce(), find(), etc. instead

Use declarative syntax:

- Use array and object destructuring
- Use the spread operator
- Use the ternary operator
- Use template literals
